{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "node_modules/browserify/node_modules/browser-resolve/empty.js",
    "node_modules/clusterfck/lib/clusterfck.js",
    "node_modules/clusterfck/lib/distance.js",
    "node_modules/clusterfck/lib/hcluster.js",
    "node_modules/clusterfck/lib/kmeans.js",
    "src/cluster/cluster.js",
    "src/cluster/clusterconsts.js",
    "src/cluster/distance.js",
    "src/consts.js",
    "src/cp.js",
    "src/gen/aggregates.js",
    "src/gen/encodings.js",
    "src/gen/gen.js",
    "src/gen/marks.js",
    "src/gen/projections.js",
    "src/gen/specs.js",
    "src/rank/rank.js",
    "src/rank/rankEncodings.js",
    "src/util.js",
    "../vega-lite/node_modules/d3-time/build/d3-time.js",
    "../vega-lite/node_modules/datalib/src/bins/bins.js",
    "../vega-lite/node_modules/datalib/src/generate.js",
    "../vega-lite/node_modules/datalib/src/time.js",
    "../vega-lite/node_modules/datalib/src/util.js",
    "../vega-lite/node_modules/json-stable-stringify/index.js",
    "../vega-lite/node_modules/jsonify/index.js",
    "../vega-lite/node_modules/jsonify/lib/parse.js",
    "../vega-lite/node_modules/jsonify/lib/stringify.js",
    "../vega-lite/src/aggregate.js",
    "../vega-lite/src/axis.js",
    "../vega-lite/src/channel.js",
    "../vega-lite/src/config.js",
    "../vega-lite/src/encoding.js",
    "../vega-lite/src/fielddef.js",
    "../vega-lite/src/legend.js",
    "../vega-lite/src/mark.js",
    "../vega-lite/src/scale.js",
    "../vega-lite/src/shorthand.js",
    "../vega-lite/src/spec.js",
    "../vega-lite/src/stack.js",
    "../vega-lite/src/timeunit.js",
    "../vega-lite/src/type.js",
    "../vega-lite/src/util.js",
    "../vega-lite/src/validate.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;;ACAA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACpSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClIA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "",
    "module.exports = {\n   hcluster: require(\"./hcluster\"),\n   Kmeans: require(\"./kmeans\"),\n   kmeans: require(\"./kmeans\").kmeans\n};",
    "module.exports = {\n  euclidean: function(v1, v2) {\n      var total = 0;\n      for (var i = 0; i < v1.length; i++) {\n         total += Math.pow(v2[i] - v1[i], 2);      \n      }\n      return Math.sqrt(total);\n   },\n   manhattan: function(v1, v2) {\n     var total = 0;\n     for (var i = 0; i < v1.length ; i++) {\n        total += Math.abs(v2[i] - v1[i]);      \n     }\n     return total;\n   },\n   max: function(v1, v2) {\n     var max = 0;\n     for (var i = 0; i < v1.length; i++) {\n        max = Math.max(max , Math.abs(v2[i] - v1[i]));      \n     }\n     return max;\n   }\n};",
    "var distances = require(\"./distance\");\n\nvar HierarchicalClustering = function(distance, linkage, threshold) {\n   this.distance = distance;\n   this.linkage = linkage;\n   this.threshold = threshold == undefined ? Infinity : threshold;\n}\n\nHierarchicalClustering.prototype = {\n   cluster : function(items, snapshotPeriod, snapshotCb) {\n      this.clusters = [];\n      this.dists = [];  // distances between each pair of clusters\n      this.mins = []; // closest cluster for each cluster\n      this.index = []; // keep a hash of all clusters by key\n      \n      for (var i = 0; i < items.length; i++) {\n         var cluster = {\n            value: items[i],\n            key: i,\n            index: i,\n            size: 1\n         };\n         this.clusters[i] = cluster;\n         this.index[i] = cluster;\n         this.dists[i] = [];\n         this.mins[i] = 0;\n      }\n\n      for (var i = 0; i < this.clusters.length; i++) {\n         for (var j = 0; j <= i; j++) {\n            var dist = (i == j) ? Infinity : \n               this.distance(this.clusters[i].value, this.clusters[j].value);\n            this.dists[i][j] = dist;\n            this.dists[j][i] = dist;\n\n            if (dist < this.dists[i][this.mins[i]]) {\n               this.mins[i] = j;               \n            }\n         }\n      }\n\n      var merged = this.mergeClosest();\n      var i = 0;\n      while (merged) {\n        if (snapshotCb && (i++ % snapshotPeriod) == 0) {\n           snapshotCb(this.clusters);           \n        }\n        merged = this.mergeClosest();\n      }\n    \n      this.clusters.forEach(function(cluster) {\n        // clean up metadata used for clustering\n        delete cluster.key;\n        delete cluster.index;\n      });\n\n      return this.clusters;\n   },\n  \n   mergeClosest: function() {\n      // find two closest clusters from cached mins\n      var minKey = 0, min = Infinity;\n      for (var i = 0; i < this.clusters.length; i++) {\n         var key = this.clusters[i].key,\n             dist = this.dists[key][this.mins[key]];\n         if (dist < min) {\n            minKey = key;\n            min = dist;\n         }\n      }\n      if (min >= this.threshold) {\n         return false;         \n      }\n\n      var c1 = this.index[minKey],\n          c2 = this.index[this.mins[minKey]];\n\n      // merge two closest clusters\n      var merged = {\n         left: c1,\n         right: c2,\n         key: c1.key,\n         size: c1.size + c2.size\n      };\n\n      this.clusters[c1.index] = merged;\n      this.clusters.splice(c2.index, 1);\n      this.index[c1.key] = merged;\n\n      // update distances with new merged cluster\n      for (var i = 0; i < this.clusters.length; i++) {\n         var ci = this.clusters[i];\n         var dist;\n         if (c1.key == ci.key) {\n            dist = Infinity;            \n         }\n         else if (this.linkage == \"single\") {\n            dist = this.dists[c1.key][ci.key];\n            if (this.dists[c1.key][ci.key] > this.dists[c2.key][ci.key]) {\n               dist = this.dists[c2.key][ci.key];\n            }\n         }\n         else if (this.linkage == \"complete\") {\n            dist = this.dists[c1.key][ci.key];\n            if (this.dists[c1.key][ci.key] < this.dists[c2.key][ci.key]) {\n               dist = this.dists[c2.key][ci.key];              \n            }\n         }\n         else if (this.linkage == \"average\") {\n            dist = (this.dists[c1.key][ci.key] * c1.size\n                   + this.dists[c2.key][ci.key] * c2.size) / (c1.size + c2.size);\n         }\n         else {\n            dist = this.distance(ci.value, c1.value);            \n         }\n\n         this.dists[c1.key][ci.key] = this.dists[ci.key][c1.key] = dist;\n      }\n\n    \n      // update cached mins\n      for (var i = 0; i < this.clusters.length; i++) {\n         var key1 = this.clusters[i].key;        \n         if (this.mins[key1] == c1.key || this.mins[key1] == c2.key) {\n            var min = key1;\n            for (var j = 0; j < this.clusters.length; j++) {\n               var key2 = this.clusters[j].key;\n               if (this.dists[key1][key2] < this.dists[key1][min]) {\n                  min = key2;                  \n               }\n            }\n            this.mins[key1] = min;\n         }\n         this.clusters[i].index = i;\n      }\n    \n      // clean up metadata used for clustering\n      delete c1.key; delete c2.key;\n      delete c1.index; delete c2.index;\n\n      return true;\n   }\n}\n\nvar hcluster = function(items, distance, linkage, threshold, snapshot, snapshotCallback) {\n   distance = distance || \"euclidean\";\n   linkage = linkage || \"average\";\n\n   if (typeof distance == \"string\") {\n     distance = distances[distance];\n   }\n   var clusters = (new HierarchicalClustering(distance, linkage, threshold))\n                  .cluster(items, snapshot, snapshotCallback);\n      \n   if (threshold === undefined) {\n      return clusters[0]; // all clustered into one\n   }\n   return clusters;\n}\n\nmodule.exports = hcluster;\n",
    "var distances = require(\"./distance\");\n\nfunction KMeans(centroids) {\n   this.centroids = centroids || [];\n}\n\nKMeans.prototype.randomCentroids = function(points, k) {\n   var centroids = points.slice(0); // copy\n   centroids.sort(function() {\n      return (Math.round(Math.random()) - 0.5);\n   });\n   return centroids.slice(0, k);\n}\n\nKMeans.prototype.classify = function(point, distance) {\n   var min = Infinity,\n       index = 0;\n\n   distance = distance || \"euclidean\";\n   if (typeof distance == \"string\") {\n      distance = distances[distance];\n   }\n\n   for (var i = 0; i < this.centroids.length; i++) {\n      var dist = distance(point, this.centroids[i]);\n      if (dist < min) {\n         min = dist;\n         index = i;\n      }\n   }\n\n   return index;\n}\n\nKMeans.prototype.cluster = function(points, k, distance, snapshotPeriod, snapshotCb) {\n   k = k || Math.max(2, Math.ceil(Math.sqrt(points.length / 2)));\n\n   distance = distance || \"euclidean\";\n   if (typeof distance == \"string\") {\n      distance = distances[distance];\n   }\n\n   this.centroids = this.randomCentroids(points, k);\n\n   var assignment = new Array(points.length);\n   var clusters = new Array(k);\n\n   var iterations = 0;\n   var movement = true;\n   while (movement) {\n      // update point-to-centroid assignments\n      for (var i = 0; i < points.length; i++) {\n         assignment[i] = this.classify(points[i], distance);\n      }\n\n      // update location of each centroid\n      movement = false;\n      for (var j = 0; j < k; j++) {\n         var assigned = [];\n         for (var i = 0; i < assignment.length; i++) {\n            if (assignment[i] == j) {\n               assigned.push(points[i]);\n            }\n         }\n\n         if (!assigned.length) {\n            continue;\n         }\n\n         var centroid = this.centroids[j];\n         var newCentroid = new Array(centroid.length);\n\n         for (var g = 0; g < centroid.length; g++) {\n            var sum = 0;\n            for (var i = 0; i < assigned.length; i++) {\n               sum += assigned[i][g];\n            }\n            newCentroid[g] = sum / assigned.length;\n\n            if (newCentroid[g] != centroid[g]) {\n               movement = true;\n            }\n         }\n\n         this.centroids[j] = newCentroid;\n         clusters[j] = assigned;\n      }\n\n      if (snapshotCb && (iterations++ % snapshotPeriod == 0)) {\n         snapshotCb(clusters);\n      }\n   }\n\n   return clusters;\n}\n\nKMeans.prototype.toJSON = function() {\n   return JSON.stringify(this.centroids);\n}\n\nKMeans.prototype.fromJSON = function(json) {\n   this.centroids = JSON.parse(json);\n   return this;\n}\n\nmodule.exports = KMeans;\n\nmodule.exports.kmeans = function(vectors, k) {\n   return (new KMeans()).cluster(vectors, k);\n}",
    "\"use strict\";\nvar vlShorthand = require('vega-lite/src/shorthand');\nvar clusterfck = require('clusterfck');\nvar consts = require('./clusterconsts');\nvar util = require('../util');\nvar clDistance = require('./distance');\nexports.distance = clDistance;\nfunction cluster(specs, opt) {\n    var dist = exports.distance.table(specs);\n    var clusterTrees = clusterfck.hcluster(specs, function (e1, e2) {\n        var s1 = vlShorthand.shorten(e1), s2 = vlShorthand.shorten(e2);\n        return dist[s1][s2];\n    }, 'average', consts.CLUSTER_THRESHOLD);\n    var clusters = clusterTrees.map(function (tree) {\n        return util.traverse(tree, []);\n    })\n        .map(function (cluster) {\n        return cluster.sort(function (spec1, spec2) {\n            return spec2._info.score - spec1._info.score;\n        });\n    }).filter(function (cluster) {\n        return cluster.length > 0;\n    }).sort(function (cluster1, cluster2) {\n        return cluster2[0]._info.score - cluster1[0]._info.score;\n    });\n    clusters.dist = dist;\n    return clusters;\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = cluster;\n//# sourceMappingURL=cluster.js.map",
    "'use strict';\nexports.SWAPPABLE = 0.05;\nexports.DIST_MISSING = 1;\nexports.CLUSTER_THRESHOLD = 1;\nfunction reduceTupleToTable(r, x) {\n    var a = x[0], b = x[1], d = x[2];\n    r[a] = r[a] || {};\n    r[b] = r[b] || {};\n    r[a][b] = r[b][a] = d;\n    return r;\n}\nexports.DIST_BY_CHANNEL = [\n    ['x', 'y', exports.SWAPPABLE],\n    ['row', 'column', exports.SWAPPABLE],\n    ['color', 'shape', exports.SWAPPABLE],\n    ['color', 'detail', exports.SWAPPABLE],\n    ['detail', 'shape', exports.SWAPPABLE],\n    ['size', 'color', exports.SWAPPABLE]\n].reduce(reduceTupleToTable, {});\n//# sourceMappingURL=clusterconsts.js.map",
    "\"use strict\";\nvar vlSpec = require('vega-lite/src/spec');\nvar vlShorthand = require('vega-lite/src/shorthand');\nvar consts = require('./clusterconsts');\nvar util = require('../util');\nfunction table(specs) {\n    var len = specs.length, extendedSpecs = specs.map(function (e) { return extendSpecWithChannelByColumnName(e); }), shorthands = specs.map(vlShorthand.shorten), diff = {}, i, j;\n    for (i = 0; i < len; i++) {\n        diff[shorthands[i]] = {};\n    }\n    for (i = 0; i < len; i++) {\n        for (j = i + 1; j < len; j++) {\n            var sj = shorthands[j], si = shorthands[i];\n            diff[sj][si] = diff[si][sj] = get(extendedSpecs[i], extendedSpecs[j]);\n        }\n    }\n    return diff;\n}\nexports.table = table;\nfunction get(extendedSpec1, extendedSpec2) {\n    var cols = util.union(util.keys(extendedSpec1.channelByField), util.keys(extendedSpec2.channelByField)), dist = 0;\n    cols.forEach(function (column) {\n        var e1 = extendedSpec1.channelByField[column], e2 = extendedSpec2.channelByField[column];\n        if (e1 && e2) {\n            if (e1.channel !== e2.channel) {\n                dist += (consts.DIST_BY_CHANNEL[e1.channel] || {})[e2.channel] || 1;\n            }\n        }\n        else {\n            dist += consts.DIST_MISSING;\n        }\n    });\n    var isStack1 = vlSpec.isStacked(extendedSpec1), isStack2 = vlSpec.isStacked(extendedSpec2);\n    if (isStack1 || isStack2) {\n        if (isStack1 && isStack2) {\n            if ((extendedSpec1.encoding.color && extendedSpec2.encoding.color &&\n                extendedSpec1.encoding.color.field !== extendedSpec2.encoding.color.field) ||\n                (extendedSpec1.encoding.detail && extendedSpec2.encoding.detail &&\n                    extendedSpec1.encoding.detail.field !== extendedSpec2.encoding.detail.field)) {\n                dist += 1;\n            }\n        }\n        else {\n            dist += 1;\n        }\n    }\n    return dist;\n}\nexports.get = get;\nfunction extendSpecWithChannelByColumnName(spec) {\n    var _channelByField = {}, encoding = spec.encoding;\n    util.keys(encoding).forEach(function (channel) {\n        var e = util.duplicate(encoding[channel]);\n        e.channel = channel;\n        _channelByField[e.field || ''] = e;\n        delete e.field;\n    });\n    return {\n        mark: spec.mark,\n        channelByField: _channelByField,\n        encoding: spec.encoding\n    };\n}\nexports.extendSpecWithChannelByColumnName = extendSpecWithChannelByColumnName;\n//# sourceMappingURL=distance.js.map",
    "\"use strict\";\nvar channel_1 = require('vega-lite/src/channel');\nvar mark_1 = require('vega-lite/src/mark');\nexports.DEFAULT_PROJECTION_OPT = {\n    omitDotPlot: false,\n    maxCardinalityForAutoAddOrdinal: 50,\n    alwaysAddHistogram: true,\n    maxAdditionalVariables: 1\n};\n(function (TableType) {\n    TableType[TableType[\"BOTH\"] = 'both'] = \"BOTH\";\n    TableType[TableType[\"AGGREGATED\"] = 'aggregated'] = \"AGGREGATED\";\n    TableType[TableType[\"DISAGGREGATED\"] = 'disaggregated'] = \"DISAGGREGATED\";\n})(exports.TableType || (exports.TableType = {}));\nvar TableType = exports.TableType;\n(function (QuantitativeDimensionType) {\n    QuantitativeDimensionType[QuantitativeDimensionType[\"AUTO\"] = 'auto'] = \"AUTO\";\n    QuantitativeDimensionType[QuantitativeDimensionType[\"BIN\"] = 'bin'] = \"BIN\";\n    QuantitativeDimensionType[QuantitativeDimensionType[\"CAST\"] = 'cast'] = \"CAST\";\n    QuantitativeDimensionType[QuantitativeDimensionType[\"NONE\"] = 'none'] = \"NONE\";\n})(exports.QuantitativeDimensionType || (exports.QuantitativeDimensionType = {}));\nvar QuantitativeDimensionType = exports.QuantitativeDimensionType;\nexports.DEFAULT_AGGREGATION_OPTIONS = {\n    tableTypes: TableType.BOTH,\n    genDimQ: QuantitativeDimensionType.AUTO,\n    minCardinalityForBin: 20,\n    omitDotPlot: false,\n    omitMeasureOnly: false,\n    omitDimensionOnly: true,\n    addCountForDimensionOnly: true,\n    aggrList: [undefined, 'mean'],\n    timeUnitList: ['year'],\n    consistentAutoQ: true\n};\nexports.DEFAULT_SCALE_OPTION = {\n    rescaleQuantitative: [undefined]\n};\n;\nexports.DEFAULT_SPEC_OPTION = {\n    markList: [mark_1.Mark.POINT, mark_1.Mark.BAR, mark_1.Mark.LINE, mark_1.Mark.AREA, mark_1.Mark.TEXT, mark_1.Mark.TICK],\n    channelList: [channel_1.X, channel_1.Y, channel_1.ROW, channel_1.COLUMN, channel_1.SIZE, channel_1.COLOR, channel_1.TEXT, channel_1.DETAIL],\n    alwaysGenerateTableAsHeatmap: true,\n    maxGoodCardinalityForFacets: 5,\n    maxCardinalityForFacets: 20,\n    maxGoodCardinalityForColor: 7,\n    maxCardinalityForColor: 20,\n    maxCardinalityForShape: 6,\n    omitDotPlot: false,\n    omitDotPlotWithExtraEncoding: true,\n    omitDotPlotWithFacet: true,\n    omitDotPlotWithOnlyCount: false,\n    omitMultipleNonPositionalChannels: true,\n    omitNonTextAggrWithAllDimsOnFacets: true,\n    omitRawWithXYBothDimension: true,\n    omitShapeWithBin: true,\n    omitShapeWithTimeDimension: true,\n    omitSizeOnBar: true,\n    omitLengthForLogScale: true,\n    omitStackedAverage: true,\n    omitTranspose: true,\n};\n//# sourceMappingURL=consts.js.map",
    "\"use strict\";\nvar cpConsts = require('./consts');\nvar cluster_1 = require('./cluster/cluster');\nvar cpGen = require('./gen/gen');\nvar cpRank = require('./rank/rank');\nvar cpUtil = require('./util');\nexports.consts = cpConsts;\nexports.cluster = cluster_1.default;\nexports.gen = cpGen;\nexports.rank = cpRank;\nexports.util = cpUtil;\nexports.auto = '-, sum';\nexports.version = '0.7.1';\n//# sourceMappingURL=cp.js.map",
    "'use strict';\nvar vlFieldDef = require('vega-lite/src/fielddef');\nvar vlShorthand = require('vega-lite/src/shorthand');\nvar type_1 = require('vega-lite/src/type');\nvar aggregate_1 = require('vega-lite/src/aggregate');\nvar util = require('../util');\nvar consts_1 = require('../consts');\nvar AUTO = '*';\nfunction genAggregates(output, fieldDefs, stats, opt) {\n    if (opt === void 0) { opt = {}; }\n    opt = util.extend({}, consts_1.DEFAULT_AGGREGATION_OPTIONS, opt);\n    var tf = new Array(fieldDefs.length);\n    var hasNorO = util.any(fieldDefs, function (f) {\n        return f.type === type_1.Type.NOMINAL || f.type === type_1.Type.ORDINAL;\n    });\n    function emit(fieldSet) {\n        fieldSet = util.duplicate(fieldSet);\n        fieldSet.key = fieldSet.map(function (fieldDef) {\n            return vlShorthand.shortenFieldDef(fieldDef);\n        }).join(vlShorthand.DELIM);\n        output.push(fieldSet);\n    }\n    function checkAndPush() {\n        if (opt.omitMeasureOnly || opt.omitDimensionOnly) {\n            var hasMeasure = false, hasDimension = false, hasRaw = false;\n            tf.forEach(function (f) {\n                if (vlFieldDef.isDimension(f)) {\n                    hasDimension = true;\n                }\n                else {\n                    hasMeasure = true;\n                    if (!f.aggregate) {\n                        hasRaw = true;\n                    }\n                }\n            });\n            if (!hasDimension && !hasRaw && opt.omitMeasureOnly) {\n                return;\n            }\n            if (!hasMeasure) {\n                if (opt.addCountForDimensionOnly) {\n                    tf.push(vlFieldDef.count());\n                    emit(tf);\n                    tf.pop();\n                }\n                if (opt.omitDimensionOnly) {\n                    return;\n                }\n            }\n        }\n        if (opt.omitDotPlot && tf.length === 1) {\n            return;\n        }\n        emit(tf);\n    }\n    function assignAggrQ(i, hasAggr, autoMode, a) {\n        var canHaveAggr = hasAggr === true || hasAggr === null, cantHaveAggr = hasAggr === false || hasAggr === null;\n        if (a) {\n            if (canHaveAggr) {\n                tf[i].aggregate = a;\n                assignField(i + 1, true, autoMode);\n                delete tf[i].aggregate;\n            }\n        }\n        else {\n            if (cantHaveAggr) {\n                assignField(i + 1, false, autoMode);\n            }\n        }\n    }\n    function assignBinQ(i, hasAggr, autoMode) {\n        tf[i].bin = true;\n        assignField(i + 1, hasAggr, autoMode);\n        delete tf[i].bin;\n    }\n    function assignQ(i, hasAggr, autoMode) {\n        var f = fieldDefs[i], canHaveAggr = hasAggr === true || hasAggr === null;\n        tf[i] = { field: f.field, type: f.type };\n        if (f.aggregate === aggregate_1.AggregateOp.COUNT) {\n            if (canHaveAggr) {\n                tf[i].aggregate = f.aggregate;\n                assignField(i + 1, true, autoMode);\n            }\n        }\n        else if (f._aggregate) {\n            assignAggrQ(i, hasAggr, autoMode, f._aggregate);\n        }\n        else if (f._raw) {\n            assignAggrQ(i, hasAggr, autoMode, undefined);\n        }\n        else if (f._bin) {\n            assignBinQ(i, hasAggr, autoMode);\n        }\n        else {\n            opt.aggrList.forEach(function (a) {\n                if (!opt.consistentAutoQ || autoMode === AUTO || autoMode === a) {\n                    assignAggrQ(i, hasAggr, a, a);\n                }\n            });\n            if ((!opt.consistentAutoQ || util.isin(autoMode, [AUTO, 'bin', 'cast', 'autocast'])) && !hasNorO) {\n                var highCardinality = vlFieldDef.cardinality(f, stats) > opt.minCardinalityForBin;\n                var isAuto = opt.genDimQ === consts_1.QuantitativeDimensionType.AUTO, genBin = opt.genDimQ === consts_1.QuantitativeDimensionType.BIN || (isAuto && highCardinality), genCast = opt.genDimQ === consts_1.QuantitativeDimensionType.CAST || (isAuto && !highCardinality);\n                if (genBin && util.isin(autoMode, [AUTO, 'bin', 'autocast'])) {\n                    assignBinQ(i, hasAggr, isAuto ? 'autocast' : 'bin');\n                }\n                if (genCast && util.isin(autoMode, [AUTO, 'cast', 'autocast'])) {\n                    tf[i].type = type_1.Type.ORDINAL;\n                    assignField(i + 1, hasAggr, isAuto ? 'autocast' : 'cast');\n                    tf[i].type = type_1.Type.QUANTITATIVE;\n                }\n            }\n        }\n    }\n    function assignTimeUnitT(i, hasAggr, autoMode, timeUnit) {\n        tf[i].timeUnit = timeUnit;\n        assignField(i + 1, hasAggr, autoMode);\n        delete tf[i].timeUnit;\n    }\n    function assignT(i, hasAggr, autoMode) {\n        var f = fieldDefs[i];\n        tf[i] = { field: f.field, type: f.type };\n        if (f._timeUnit) {\n            assignTimeUnitT(i, hasAggr, autoMode, f._timeUnit);\n        }\n        else {\n            opt.timeUnitList.forEach(function (timeUnit) {\n                if (timeUnit === undefined) {\n                    if (!hasAggr) {\n                        assignField(i + 1, false, autoMode);\n                    }\n                }\n                else {\n                    assignTimeUnitT(i, hasAggr, autoMode, timeUnit);\n                }\n            });\n        }\n    }\n    function assignField(i, hasAggr, autoMode) {\n        if (i === fieldDefs.length) {\n            checkAndPush();\n            return;\n        }\n        var f = fieldDefs[i];\n        switch (f.type) {\n            case type_1.Type.QUANTITATIVE:\n                assignQ(i, hasAggr, autoMode);\n                break;\n            case type_1.Type.TEMPORAL:\n                assignT(i, hasAggr, autoMode);\n                break;\n            case type_1.Type.ORDINAL:\n            case type_1.Type.NOMINAL:\n            default:\n                tf[i] = f;\n                assignField(i + 1, hasAggr, autoMode);\n                break;\n        }\n    }\n    var hasAggr = opt.tableTypes === consts_1.TableType.AGGREGATED ? true :\n        opt.tableTypes === consts_1.TableType.DISAGGREGATED ? false : null;\n    assignField(0, hasAggr, AUTO);\n    return output;\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = genAggregates;\n//# sourceMappingURL=aggregates.js.map",
    "\"use strict\";\nvar fielddef_1 = require('vega-lite/src/fielddef');\nvar encoding_1 = require('vega-lite/src/encoding');\nvar util_1 = require('../util');\nvar marks_1 = require('./marks');\nvar consts_1 = require('../consts');\nvar aggregate_1 = require('vega-lite/src/aggregate');\nvar channel_1 = require('vega-lite/src/channel');\nvar type_1 = require('vega-lite/src/type');\nfunction genEncodings(encodings, fieldDefs, stats, opt) {\n    if (opt === void 0) { opt = consts_1.DEFAULT_SPEC_OPTION; }\n    var tmpEncoding = {};\n    function assignField(i) {\n        if (i === fieldDefs.length) {\n            if (rule.encoding(tmpEncoding, stats, opt)) {\n                encodings.push(util_1.duplicate(tmpEncoding));\n            }\n            return;\n        }\n        var fieldDef = fieldDefs[i];\n        for (var j in opt.channelList) {\n            var channel = opt.channelList[j], isDim = fielddef_1.isDimension(fieldDef);\n            var supportedRole = channel_1.getSupportedRole(channel);\n            if (!(channel in tmpEncoding) &&\n                ((isDim && supportedRole.dimension) || (!isDim && supportedRole.measure)) &&\n                rule.channel[channel](tmpEncoding, fieldDef, stats, opt)) {\n                tmpEncoding[channel] = fieldDef;\n                assignField(i + 1);\n                delete tmpEncoding[channel];\n            }\n        }\n    }\n    assignField(0);\n    return encodings;\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = genEncodings;\nvar rule;\n(function (rule) {\n    var channel;\n    (function (channel) {\n        channel.x = noRule;\n        channel.y = noRule;\n        channel.text = noRule;\n        channel.detail = noRule;\n        channel.size = retinalEncRules;\n        channel.row = noRule;\n        channel.column = noRule;\n        function color(encoding, fieldDef, stats, opt) {\n            if (!retinalEncRules(encoding, fieldDef, stats, opt)) {\n                return false;\n            }\n            return fielddef_1.isMeasure(fieldDef) ||\n                fielddef_1.cardinality(fieldDef, stats) <= opt.maxCardinalityForColor;\n        }\n        channel.color = color;\n        function shape(encoding, fieldDef, stats, opt) {\n            if (!retinalEncRules(encoding, fieldDef, stats, opt)) {\n                return false;\n            }\n            if (opt.omitShapeWithBin && fieldDef.bin && fieldDef.type === type_1.Type.QUANTITATIVE) {\n                return false;\n            }\n            if (opt.omitShapeWithTimeDimension && fieldDef.timeUnit && fieldDef.type === type_1.Type.TEMPORAL) {\n                return false;\n            }\n            return fielddef_1.cardinality(fieldDef, stats) <= opt.maxCardinalityForShape;\n        }\n        channel.shape = shape;\n        function noRule() { return true; }\n        function retinalEncRules(encoding, fieldDef, stats, opt) {\n            if (opt.omitMultipleNonPositionalChannels) {\n                if (encoding.color || encoding.size || encoding.shape) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    })(channel = rule.channel || (rule.channel = {}));\n    function dotPlotRules(encoding, stats, opt) {\n        if (opt.omitDotPlot) {\n            return false;\n        }\n        if (opt.omitTranspose && encoding.y) {\n            return false;\n        }\n        if (opt.omitDotPlotWithFacet && (encoding.row || encoding.column)) {\n            return false;\n        }\n        if (opt.omitDotPlotWithExtraEncoding && util_1.keys(encoding).length > 1) {\n            return false;\n        }\n        if (opt.omitDotPlotWithOnlyCount) {\n            if (encoding.x && encoding.x.aggregate === aggregate_1.AggregateOp.COUNT && !encoding.y) {\n                return false;\n            }\n            if (encoding.y && encoding.y.aggregate === aggregate_1.AggregateOp.COUNT && !encoding.x) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function isAggrWithAllDimOnFacets(encoding) {\n        var hasAggr = false, hasOtherO = false;\n        for (var c in encoding) {\n            var channel_2 = c;\n            var fieldDef = encoding[channel_2];\n            if (fieldDef.aggregate) {\n                hasAggr = true;\n            }\n            if (fielddef_1.isDimension(fieldDef) && (channel_2 !== channel_1.ROW && channel_2 !== channel_1.COLUMN)) {\n                hasOtherO = true;\n            }\n            if (hasAggr && hasOtherO) {\n                break;\n            }\n        }\n        return hasAggr && !hasOtherO;\n    }\n    ;\n    function xyPlotRules(encoding, stats, opt) {\n        if (encoding.row || encoding.column) {\n            if (opt.omitNonTextAggrWithAllDimsOnFacets) {\n                if (isAggrWithAllDimOnFacets(encoding)) {\n                    return false;\n                }\n            }\n        }\n        var isDimX = fielddef_1.isDimension(encoding.x), isDimY = fielddef_1.isDimension(encoding.y);\n        if (opt.omitRawWithXYBothDimension && isDimX && isDimY && !encoding_1.isAggregate(encoding)) {\n            return false;\n        }\n        if (opt.omitTranspose) {\n            if (isDimX !== isDimY) {\n                if ((encoding.y.type === type_1.Type.NOMINAL || encoding.y.type === type_1.Type.ORDINAL) && fielddef_1.isMeasure(encoding.x)) {\n                    return true;\n                }\n                if (!isDimY && isDimX && !(encoding.x.type === type_1.Type.NOMINAL || encoding.x.type === type_1.Type.ORDINAL)) {\n                    return true;\n                }\n                return false;\n            }\n            else if (encoding.y.type === type_1.Type.TEMPORAL || encoding.x.type === type_1.Type.TEMPORAL) {\n                if (encoding.y.type === type_1.Type.TEMPORAL && encoding.x.type !== type_1.Type.TEMPORAL) {\n                    return false;\n                }\n            }\n            else {\n                if (encoding.x.field > encoding.y.field) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    function encoding(encoding, stats, opt) {\n        if (encoding.text) {\n            return marks_1.rule.text(encoding, stats, opt);\n        }\n        var hasX = !!encoding.x, hasY = !!encoding.y;\n        if (hasX !== hasY) {\n            return dotPlotRules(encoding, stats, opt);\n        }\n        else if (hasX && hasY) {\n            return xyPlotRules(encoding, stats, opt);\n        }\n        return false;\n    }\n    rule.encoding = encoding;\n})(rule || (rule = {}));\n//# sourceMappingURL=encodings.js.map",
    "'use strict';\nvar aggregates_1 = require('./aggregates');\nvar projections_1 = require('./projections');\nvar projections_2 = require('./projections');\nvar specs_1 = require('./specs');\nvar encodings_1 = require('./encodings');\nvar marks_1 = require('./marks');\nexports.aggregates = aggregates_1.default;\nexports.projections = projections_1.default;\nexports.projections.key = projections_2.key;\nexports.specs = specs_1.default;\nexports.encodings = encodings_1.default;\nexports.marks = marks_1.default;\n//# sourceMappingURL=gen.js.map",
    "\"use strict\";\nvar encoding_1 = require('vega-lite/src/encoding');\nvar fielddef_1 = require('vega-lite/src/fielddef');\nvar validate_1 = require('vega-lite/src/validate');\nvar type_1 = require('vega-lite/src/type');\nvar scale_1 = require('vega-lite/src/scale');\nvar aggregate_1 = require('vega-lite/src/aggregate');\nvar util = require('../util');\nfunction genMarks(encoding, stats, opt) {\n    return opt.markList.filter(function (mark) {\n        var noVlError = validate_1.getEncodingMappingError({\n            mark: mark,\n            encoding: encoding\n        }) === null;\n        return noVlError && rule[mark](encoding, stats, opt);\n    });\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = genMarks;\nvar rule;\n(function (rule) {\n    function facetRule(fieldDef, stats, opt) {\n        return fielddef_1.cardinality(fieldDef, stats) <= opt.maxCardinalityForFacets;\n    }\n    function facetsRule(encoding, stats, opt) {\n        if (encoding.row && !facetRule(encoding.row, stats, opt))\n            return false;\n        if (encoding.column && !facetRule(encoding.column, stats, opt))\n            return false;\n        return true;\n    }\n    function point(encoding, stats, opt) {\n        if (!facetsRule(encoding, stats, opt))\n            return false;\n        if (encoding.x && encoding.y) {\n            var xIsDim = fielddef_1.isDimension(encoding.x), yIsDim = fielddef_1.isDimension(encoding.y);\n            if (xIsDim && yIsDim) {\n                if (encoding.shape) {\n                    return false;\n                }\n                if (encoding.color && fielddef_1.isDimension(encoding.color)) {\n                    return false;\n                }\n            }\n        }\n        else {\n            if (opt.omitDotPlot)\n                return false;\n            if (opt.omitTranspose && encoding.y)\n                return false;\n            if (opt.omitDotPlotWithExtraEncoding && util.keys(encoding).length > 1)\n                return false;\n        }\n        return true;\n    }\n    rule.point = point;\n    function tick(encoding, stats, opt) {\n        if (encoding.x || encoding.y) {\n            if (encoding_1.isAggregate(encoding))\n                return false;\n            var xIsDim = fielddef_1.isDimension(encoding.x), yIsDim = fielddef_1.isDimension(encoding.y);\n            return (!xIsDim && (!encoding.y || yIsDim)) ||\n                (!yIsDim && (!encoding.x || xIsDim));\n        }\n        return false;\n    }\n    rule.tick = tick;\n    function bar(encoding, stats, opt) {\n        if (!facetsRule(encoding, stats, opt))\n            return false;\n        if (!encoding.x && !encoding.y)\n            return false;\n        if (opt.omitSizeOnBar && encoding.size !== undefined)\n            return false;\n        if (opt.omitLengthForLogScale) {\n            if (encoding.x && encoding.x.scale && encoding.x.scale.type === scale_1.ScaleType.LOG)\n                return false;\n            if (encoding.y && encoding.y.scale && encoding.y.scale.type === scale_1.ScaleType.LOG)\n                return false;\n        }\n        var aggEitherXorY = (!encoding.x || encoding.x.aggregate === undefined) !==\n            (!encoding.y || encoding.y.aggregate === undefined);\n        if (aggEitherXorY) {\n            var eitherXorYisDimOrNull = (!encoding.x || fielddef_1.isDimension(encoding.x)) !==\n                (!encoding.y || fielddef_1.isDimension(encoding.y));\n            if (eitherXorYisDimOrNull) {\n                var aggregate = encoding.x.aggregate || encoding.y.aggregate;\n                return !(opt.omitStackedAverage && aggregate === aggregate_1.AggregateOp.MEAN && encoding.color);\n            }\n        }\n        return false;\n    }\n    rule.bar = bar;\n    function line(encoding, stats, opt) {\n        if (!facetsRule(encoding, stats, opt))\n            return false;\n        return encoding.x.type === type_1.Type.TEMPORAL && !!encoding.x.timeUnit &&\n            encoding.y.type === type_1.Type.QUANTITATIVE && !!encoding.y.aggregate;\n    }\n    rule.line = line;\n    function area(encoding, stats, opt) {\n        if (!facetsRule(encoding, stats, opt))\n            return false;\n        if (!line(encoding, stats, opt))\n            return false;\n        if (opt.omitLengthForLogScale) {\n            if (encoding.x && encoding.x.scale && encoding.x.scale.type === scale_1.ScaleType.LOG)\n                return false;\n            if (encoding.y && encoding.y.scale && encoding.y.scale.type === scale_1.ScaleType.LOG)\n                return false;\n        }\n        return !(opt.omitStackedAverage && encoding.y.aggregate === aggregate_1.AggregateOp.MEAN && encoding.color);\n    }\n    rule.area = area;\n    function text(encoding, stats, opt) {\n        return (encoding.row || encoding.column) && encoding.text && encoding.text.aggregate && !encoding.x && !encoding.y && !encoding.size &&\n            (!opt.alwaysGenerateTableAsHeatmap || !encoding.color);\n    }\n    rule.text = text;\n})(rule = exports.rule || (exports.rule = {}));\n//# sourceMappingURL=marks.js.map",
    "\"use strict\";\nvar vlFieldDef = require('vega-lite/src/fielddef');\nvar util = require('../util');\nvar consts_1 = require('../consts');\nvar type_1 = require('vega-lite/src/type');\nvar isDimension = vlFieldDef.isDimension;\nfunction projections(fieldDefs, stats, opt) {\n    if (opt === void 0) { opt = {}; }\n    opt = util.extend({}, consts_1.DEFAULT_PROJECTION_OPT, opt);\n    var selected = [], fieldsToAdd = [], fieldSets = [];\n    var hasSelectedDimension = false, hasSelectedMeasure = false;\n    var indices = {};\n    fieldDefs.forEach(function (fieldDef, index) {\n        indices[fieldDef.field] = index;\n        if (fieldDef.selected) {\n            selected.push(fieldDef);\n            if (isDimension(fieldDef) ||\n                (fieldDef.type === type_1.TEMPORAL)) {\n                hasSelectedDimension = true;\n            }\n            else {\n                hasSelectedMeasure = true;\n            }\n        }\n        else if (fieldDef.selected !== false && !vlFieldDef.isCount(fieldDef)) {\n            if (vlFieldDef.isDimension(fieldDef) &&\n                !opt.maxCardinalityForAutoAddOrdinal &&\n                vlFieldDef.cardinality(fieldDef, stats, 15) > opt.maxCardinalityForAutoAddOrdinal) {\n                return;\n            }\n            fieldsToAdd.push(fieldDef);\n        }\n    });\n    fieldsToAdd.sort(compareFieldsToAdd(hasSelectedDimension, hasSelectedMeasure, indices));\n    var setsToAdd = util.chooseKorLess(fieldsToAdd, opt.maxAdditionalVariables);\n    setsToAdd.forEach(function (setToAdd) {\n        var fieldSet = selected.concat(setToAdd);\n        if (fieldSet.length > 0) {\n            if (opt.omitDotPlot && fieldSet.length === 1) {\n                return;\n            }\n            fieldSets.push(fieldSet);\n        }\n    });\n    fieldSets.forEach(function (fieldSet) {\n        fieldSet.key = key(fieldSet);\n    });\n    return fieldSets;\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = projections;\nvar typeIsMeasureScore = {\n    nominal: 0,\n    ordinal: 0,\n    temporal: 2,\n    quantitative: 3\n};\nfunction compareFieldsToAdd(hasSelectedDimension, hasSelectedMeasure, indices) {\n    return function (a, b) {\n        if (a.type !== b.type) {\n            if (!hasSelectedDimension) {\n                return typeIsMeasureScore[a.type] - typeIsMeasureScore[b.type];\n            }\n            else {\n                return typeIsMeasureScore[b.type] - typeIsMeasureScore[a.type];\n            }\n        }\n        return indices[a.field] - indices[b.field];\n    };\n}\nfunction key(projection) {\n    return projection.map(function (fieldDef) {\n        return vlFieldDef.isCount(fieldDef) ? 'count' : fieldDef.field;\n    }).join(',');\n}\nexports.key = key;\n;\n//# sourceMappingURL=projections.js.map",
    "'use strict';\nvar vlFieldDef = require('vega-lite/src/fielddef');\nvar util = require('../util');\nvar consts_1 = require('../consts');\nvar encodings_1 = require('./encodings');\nvar marks_1 = require('./marks');\nvar rank = require('../rank/rank');\nvar shorthand_1 = require('vega-lite/src/shorthand');\nfunction genSpecsFromFieldDefs(output, fieldDefs, stats, opt, nested) {\n    if (opt === void 0) { opt = {}; }\n    opt = util.extend({}, consts_1.DEFAULT_SPEC_OPTION, opt);\n    var encodings = encodings_1.default([], fieldDefs, stats, opt);\n    if (nested) {\n        return encodings.reduce(function (dict, encoding) {\n            var encodingShorthand = shorthand_1.shortenEncoding(encoding);\n            dict[encodingShorthand] = genSpecsFromEncodings([], encoding, stats, opt);\n            return dict;\n        }, {});\n    }\n    else {\n        return encodings.reduce(function (list, encoding) {\n            return genSpecsFromEncodings(list, encoding, stats, opt);\n        }, output);\n    }\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = genSpecsFromFieldDefs;\nfunction genSpecsFromEncodings(output, encoding, stats, opt) {\n    marks_1.default(encoding, stats, opt)\n        .forEach(function (mark) {\n        var spec = util.duplicate({\n            encoding: encoding,\n            config: opt.config\n        });\n        spec.mark = mark;\n        spec.data = opt.data;\n        spec = finalTouch(spec, stats, opt);\n        var score = rank.encoding(spec, stats, opt);\n        spec._info = score;\n        output.push(spec);\n    });\n    return output;\n}\nfunction finalTouch(spec, stats, opt) {\n    if (spec.mark === 'text' && opt.alwaysGenerateTableAsHeatmap) {\n        spec.encoding.color = spec.encoding.text;\n    }\n    var encoding = spec.encoding;\n    ['x', 'y'].forEach(function (channel) {\n        var fieldDef = encoding[channel];\n        if (fieldDef && vlFieldDef.isMeasure(fieldDef) && !vlFieldDef.isCount(fieldDef)) {\n            var stat = stats[fieldDef.field];\n            if (stat && stat.stdev / stat.mean < 0.01) {\n                fieldDef.scale = { zero: false };\n            }\n        }\n    });\n    return spec;\n}\n//# sourceMappingURL=specs.js.map",
    "\"use strict\";\nvar rankEncodings_1 = require('./rankEncodings');\nexports.encoding = rankEncodings_1.default;\n//# sourceMappingURL=rank.js.map",
    "'use strict';\nvar vlEncoding = require('vega-lite/src/encoding');\nvar vlFieldDef = require('vega-lite/src/fielddef');\nvar vlChannel = require('vega-lite/src/channel');\nvar isDimension = vlFieldDef.isDimension;\nvar util = require('../util');\nvar vlShorthand = require('vega-lite/src/shorthand');\nvar type_1 = require('vega-lite/src/type');\nvar mark_1 = require('vega-lite/src/mark');\nvar UNUSED_POSITION = 0.5;\nvar MARK_SCORE = {\n    line: 0.99,\n    area: 0.98,\n    bar: 0.97,\n    tick: 0.96,\n    point: 0.95,\n    circle: 0.94,\n    square: 0.94,\n    text: 0.8\n};\nvar D = {}, M = {}, BAD = 0.1, TERRIBLE = 0.01;\nD.minor = 0.01;\nD.pos = 1;\nD.Y_T = 0.8;\nD.facet_text = 1;\nD.facet_good = 0.675;\nD.facet_ok = 0.55;\nD.facet_bad = 0.4;\nD.color_good = 0.7;\nD.color_ok = 0.65;\nD.color_bad = 0.3;\nD.color_stack = 0.6;\nD.shape = 0.6;\nD.detail = 0.5;\nD.bad = BAD;\nD.terrible = TERRIBLE;\nM.pos = 1;\nM.size = 0.6;\nM.color = 0.5;\nM.text = 0.4;\nM.bad = BAD;\nM.terrible = TERRIBLE;\nexports.dimensionScore = function (fieldDef, channel, mark, stats, opt) {\n    var cardinality = vlFieldDef.cardinality(fieldDef, stats);\n    switch (channel) {\n        case vlChannel.X:\n            if (fieldDef.type === type_1.Type.NOMINAL || fieldDef.type === type_1.Type.ORDINAL) {\n                return D.pos - D.minor;\n            }\n            return D.pos;\n        case vlChannel.Y:\n            if (fieldDef.type === type_1.Type.NOMINAL || fieldDef.type === type_1.Type.ORDINAL) {\n                return D.pos - D.minor;\n            }\n            if (fieldDef.type === type_1.Type.TEMPORAL) {\n                return D.Y_T;\n            }\n            return D.pos - D.minor;\n        case vlChannel.COLUMN:\n            if (mark === 'text')\n                return D.facet_text;\n            return cardinality <= opt.maxGoodCardinalityForFacets ? D.facet_good :\n                cardinality <= opt.maxCardinalityForFacets ? D.facet_ok : D.facet_bad;\n        case vlChannel.ROW:\n            if (mark === 'text')\n                return D.facet_text;\n            return (cardinality <= opt.maxGoodCardinalityForFacets ? D.facet_good :\n                cardinality <= opt.maxCardinalityForFacets ? D.facet_ok : D.facet_bad) - D.minor;\n        case vlChannel.COLOR:\n            var hasOrder = (fieldDef.bin && fieldDef.type === type_1.Type.QUANTITATIVE) || (fieldDef.timeUnit && fieldDef.type === type_1.Type.TEMPORAL);\n            var isStacked = mark === mark_1.Mark.BAR || mark === mark_1.Mark.AREA;\n            if (hasOrder)\n                return D.color_bad;\n            if (isStacked)\n                return D.color_stack;\n            return cardinality <= opt.maxGoodCardinalityForColor ? D.color_good : cardinality <= opt.maxCardinalityForColor ? D.color_ok : D.color_bad;\n        case vlChannel.SHAPE:\n            return cardinality <= opt.maxCardinalityForShape ? D.shape : TERRIBLE;\n        case vlChannel.DETAIL:\n            return D.detail;\n    }\n    return TERRIBLE;\n};\nexports.dimensionScore.consts = D;\nexports.measureScore = function (fieldDef, channel, mark, stats, opt) {\n    switch (channel) {\n        case vlChannel.X: return M.pos;\n        case vlChannel.Y: return M.pos;\n        case vlChannel.SIZE:\n            if (mark === mark_1.Mark.BAR || mark === mark_1.Mark.TEXT || mark === mark_1.Mark.LINE) {\n                return BAD;\n            }\n            return M.size;\n        case vlChannel.COLOR: return M.color;\n        case vlChannel.TEXT: return M.text;\n    }\n    return BAD;\n};\nexports.measureScore.consts = M;\nfunction rankEncodings(spec, stats, opt, selected) {\n    var features = [], channels = util.keys(spec.encoding), mark = spec.mark, encoding = spec.encoding;\n    var encodingMappingByField = vlEncoding.reduce(spec.encoding, function (o, fieldDef, channel) {\n        var key = vlShorthand.shortenFieldDef(fieldDef);\n        var mappings = o[key] = o[key] || [];\n        mappings.push({ channel: channel, fieldDef: fieldDef });\n        return o;\n    }, {});\n    util.forEach(encodingMappingByField, function (mappings) {\n        var reasons = mappings.map(function (m) {\n            return m.channel + vlShorthand.ASSIGN + vlShorthand.shortenFieldDef(m.fieldDef) +\n                ' ' + (selected && selected[m.fieldDef.field] ? '[x]' : '[ ]');\n        }), scores = mappings.map(function (m) {\n            var roleScore = vlFieldDef.isDimension(m.fieldDef) ?\n                exports.dimensionScore : exports.measureScore;\n            var score = roleScore(m.fieldDef, m.channel, spec.mark, stats, opt);\n            return !selected || selected[m.fieldDef.field] ? score : Math.pow(score, 0.125);\n        });\n        features.push({\n            reason: reasons.join(' | '),\n            score: Math.max.apply(null, scores)\n        });\n    });\n    if (mark === 'text') {\n    }\n    else {\n        if (encoding.x && encoding.y) {\n            if (isDimension(encoding.x) !== isDimension(encoding.y)) {\n                features.push({\n                    reason: 'OxQ plot',\n                    score: 0.8\n                });\n            }\n        }\n    }\n    if (channels.length > 1 && mark !== mark_1.Mark.TEXT) {\n        if ((!encoding.x || !encoding.y) && !encoding.geo && !encoding.text) {\n            features.push({\n                reason: 'unused position',\n                score: UNUSED_POSITION\n            });\n        }\n    }\n    features.push({\n        reason: 'mark=' + mark,\n        score: MARK_SCORE[mark]\n    });\n    return {\n        score: features.reduce(function (p, f) {\n            return p * f.score;\n        }, 1),\n        features: features\n    };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = rankEncodings;\n//# sourceMappingURL=rankEncodings.js.map",
    "\"use strict\";\nexports.isArray = Array.isArray || function (obj) {\n    return {}.toString.call(obj) === '[object Array]';\n};\nfunction isin(item, array) {\n    return array.indexOf(item) !== -1;\n}\nexports.isin = isin;\n;\nfunction json(s, sp) {\n    return JSON.stringify(s, null, sp);\n}\nexports.json = json;\n;\nfunction keys(obj) {\n    var k = [], x;\n    for (x in obj) {\n        k.push(x);\n    }\n    return k;\n}\nexports.keys = keys;\n;\nfunction duplicate(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\nexports.duplicate = duplicate;\n;\nfunction forEach(obj, f, thisArg) {\n    if (obj.forEach) {\n        obj.forEach.call(thisArg, f);\n    }\n    else {\n        for (var k in obj) {\n            f.call(thisArg, obj[k], k, obj);\n        }\n    }\n}\nexports.forEach = forEach;\n;\nfunction any(arr, f) {\n    var i = 0, k;\n    for (k in arr) {\n        if (f(arr[k], k, i++)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.any = any;\n;\nfunction nestedMap(collection, f, level, filter) {\n    return level === 0 ?\n        collection.map(f) :\n        collection.map(function (v) {\n            var r = nestedMap(v, f, level - 1);\n            return filter ? r.filter(nonEmpty) : r;\n        });\n}\nexports.nestedMap = nestedMap;\n;\nfunction nestedReduce(collection, f, level, filter) {\n    return level === 0 ?\n        collection.reduce(f, []) :\n        collection.map(function (v) {\n            var r = nestedReduce(v, f, level - 1);\n            return filter ? r.filter(nonEmpty) : r;\n        });\n}\nexports.nestedReduce = nestedReduce;\n;\nfunction nonEmpty(grp) {\n    return !exports.isArray(grp) || grp.length > 0;\n}\nexports.nonEmpty = nonEmpty;\n;\nfunction traverse(node, arr) {\n    if (node.value !== undefined) {\n        arr.push(node.value);\n    }\n    else {\n        if (node.left) {\n            traverse(node.left, arr);\n        }\n        if (node.right) {\n            traverse(node.right, arr);\n        }\n    }\n    return arr;\n}\nexports.traverse = traverse;\n;\nfunction extend(obj, b) {\n    var rest = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        rest[_i - 2] = arguments[_i];\n    }\n    for (var x, name, i = 1, len = arguments.length; i < len; ++i) {\n        x = arguments[i];\n        for (name in x) {\n            obj[name] = x[name];\n        }\n    }\n    return obj;\n}\nexports.extend = extend;\n;\nfunction union(a, b) {\n    var o = {};\n    a.forEach(function (x) { o[x] = true; });\n    b.forEach(function (x) { o[x] = true; });\n    return keys(o);\n}\nexports.union = union;\n;\nvar gen;\n(function (gen) {\n    function getOpt(opt) {\n        return (opt ? keys(opt) : []).reduce(function (c, k) {\n            c[k] = opt[k];\n            return c;\n        }, Object.create({}));\n    }\n    gen.getOpt = getOpt;\n    ;\n})(gen = exports.gen || (exports.gen = {}));\nfunction powerset(list) {\n    var ps = [\n        []\n    ];\n    for (var i = 0; i < list.length; i++) {\n        for (var j = 0, len = ps.length; j < len; j++) {\n            ps.push(ps[j].concat(list[i]));\n        }\n    }\n    return ps;\n}\nexports.powerset = powerset;\n;\nfunction chooseKorLess(list, k) {\n    var subset = [[]];\n    for (var i = 0; i < list.length; i++) {\n        for (var j = 0, len = subset.length; j < len; j++) {\n            var sub = subset[j].concat(list[i]);\n            if (sub.length <= k) {\n                subset.push(sub);\n            }\n        }\n    }\n    return subset;\n}\nexports.chooseKorLess = chooseKorLess;\n;\nfunction chooseK(list, k) {\n    var subset = [[]];\n    var kArray = [];\n    for (var i = 0; i < list.length; i++) {\n        for (var j = 0, len = subset.length; j < len; j++) {\n            var sub = subset[j].concat(list[i]);\n            if (sub.length < k) {\n                subset.push(sub);\n            }\n            else if (sub.length === k) {\n                kArray.push(sub);\n            }\n        }\n    }\n    return kArray;\n}\nexports.chooseK = chooseK;\n;\nfunction cross(a, b) {\n    var x = [];\n    for (var i = 0; i < a.length; i++) {\n        for (var j = 0; j < b.length; j++) {\n            x.push(a[i].concat(b[j]));\n        }\n    }\n    return x;\n}\nexports.cross = cross;\n;\n//# sourceMappingURL=util.js.map",
    "(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define('d3-time', ['exports'], factory) :\n  factory((global.d3_time = {}));\n}(this, function (exports) { 'use strict';\n\n  var t0 = new Date;\n  var t1 = new Date;\n  function newInterval(floori, offseti, count, field) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) {\n      interval.count = function(start, end) {\n        t0.setTime(+start), t1.setTime(+end);\n        floori(t0), floori(t1);\n        return Math.floor(count(t0, t1));\n      };\n\n      interval.every = function(step) {\n        step = Math.floor(step);\n        return !isFinite(step) || !(step > 0) ? null\n            : !(step > 1) ? interval\n            : interval.filter(field\n                ? function(d) { return field(d) % step === 0; }\n                : function(d) { return interval.count(0, d) % step === 0; });\n      };\n    }\n\n    return interval;\n  };\n\n  var millisecond = newInterval(function() {\n    // noop\n  }, function(date, step) {\n    date.setTime(+date + step);\n  }, function(start, end) {\n    return end - start;\n  });\n\n  // An optimized implementation for this simple case.\n  millisecond.every = function(k) {\n    k = Math.floor(k);\n    if (!isFinite(k) || !(k > 0)) return null;\n    if (!(k > 1)) return millisecond;\n    return newInterval(function(date) {\n      date.setTime(Math.floor(date / k) * k);\n    }, function(date, step) {\n      date.setTime(+date + step * k);\n    }, function(start, end) {\n      return (end - start) / k;\n    });\n  };\n\n  var second = newInterval(function(date) {\n    date.setMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  }, function(date) {\n    return date.getSeconds();\n  });\n\n  var minute = newInterval(function(date) {\n    date.setSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  }, function(date) {\n    return date.getMinutes();\n  });\n\n  var hour = newInterval(function(date) {\n    date.setMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  }, function(date) {\n    return date.getHours();\n  });\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  }, function(date) {\n    return date.getDate() - 1;\n  });\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  var sunday = weekday(0);\n  var monday = weekday(1);\n  var tuesday = weekday(2);\n  var wednesday = weekday(3);\n  var thursday = weekday(4);\n  var friday = weekday(5);\n  var saturday = weekday(6);\n\n  var month = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setDate(1);\n  }, function(date, step) {\n    date.setMonth(date.getMonth() + step);\n  }, function(start, end) {\n    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n  }, function(date) {\n    return date.getMonth();\n  });\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  }, function(date) {\n    return date.getFullYear();\n  });\n\n  var utcSecond = newInterval(function(date) {\n    date.setUTCMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  }, function(date) {\n    return date.getUTCSeconds();\n  });\n\n  var utcMinute = newInterval(function(date) {\n    date.setUTCSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  }, function(date) {\n    return date.getUTCMinutes();\n  });\n\n  var utcHour = newInterval(function(date) {\n    date.setUTCMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  }, function(date) {\n    return date.getUTCHours();\n  });\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  }, function(date) {\n    return date.getUTCDate() - 1;\n  });\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  var utcSunday = utcWeekday(0);\n  var utcMonday = utcWeekday(1);\n  var utcTuesday = utcWeekday(2);\n  var utcWednesday = utcWeekday(3);\n  var utcThursday = utcWeekday(4);\n  var utcFriday = utcWeekday(5);\n  var utcSaturday = utcWeekday(6);\n\n  var utcMonth = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCDate(1);\n  }, function(date, step) {\n    date.setUTCMonth(date.getUTCMonth() + step);\n  }, function(start, end) {\n    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n  }, function(date) {\n    return date.getUTCMonth();\n  });\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  }, function(date) {\n    return date.getUTCFullYear();\n  });\n\n  var milliseconds = millisecond.range;\n  var seconds = second.range;\n  var minutes = minute.range;\n  var hours = hour.range;\n  var days = day.range;\n  var sundays = sunday.range;\n  var mondays = monday.range;\n  var tuesdays = tuesday.range;\n  var wednesdays = wednesday.range;\n  var thursdays = thursday.range;\n  var fridays = friday.range;\n  var saturdays = saturday.range;\n  var weeks = sunday.range;\n  var months = month.range;\n  var years = year.range;\n\n  var utcMillisecond = millisecond;\n  var utcMilliseconds = milliseconds;\n  var utcSeconds = utcSecond.range;\n  var utcMinutes = utcMinute.range;\n  var utcHours = utcHour.range;\n  var utcDays = utcDay.range;\n  var utcSundays = utcSunday.range;\n  var utcMondays = utcMonday.range;\n  var utcTuesdays = utcTuesday.range;\n  var utcWednesdays = utcWednesday.range;\n  var utcThursdays = utcThursday.range;\n  var utcFridays = utcFriday.range;\n  var utcSaturdays = utcSaturday.range;\n  var utcWeeks = utcSunday.range;\n  var utcMonths = utcMonth.range;\n  var utcYears = utcYear.range;\n\n  var version = \"0.1.1\";\n\n  exports.version = version;\n  exports.milliseconds = milliseconds;\n  exports.seconds = seconds;\n  exports.minutes = minutes;\n  exports.hours = hours;\n  exports.days = days;\n  exports.sundays = sundays;\n  exports.mondays = mondays;\n  exports.tuesdays = tuesdays;\n  exports.wednesdays = wednesdays;\n  exports.thursdays = thursdays;\n  exports.fridays = fridays;\n  exports.saturdays = saturdays;\n  exports.weeks = weeks;\n  exports.months = months;\n  exports.years = years;\n  exports.utcMillisecond = utcMillisecond;\n  exports.utcMilliseconds = utcMilliseconds;\n  exports.utcSeconds = utcSeconds;\n  exports.utcMinutes = utcMinutes;\n  exports.utcHours = utcHours;\n  exports.utcDays = utcDays;\n  exports.utcSundays = utcSundays;\n  exports.utcMondays = utcMondays;\n  exports.utcTuesdays = utcTuesdays;\n  exports.utcWednesdays = utcWednesdays;\n  exports.utcThursdays = utcThursdays;\n  exports.utcFridays = utcFridays;\n  exports.utcSaturdays = utcSaturdays;\n  exports.utcWeeks = utcWeeks;\n  exports.utcMonths = utcMonths;\n  exports.utcYears = utcYears;\n  exports.millisecond = millisecond;\n  exports.second = second;\n  exports.minute = minute;\n  exports.hour = hour;\n  exports.day = day;\n  exports.sunday = sunday;\n  exports.monday = monday;\n  exports.tuesday = tuesday;\n  exports.wednesday = wednesday;\n  exports.thursday = thursday;\n  exports.friday = friday;\n  exports.saturday = saturday;\n  exports.week = sunday;\n  exports.month = month;\n  exports.year = year;\n  exports.utcSecond = utcSecond;\n  exports.utcMinute = utcMinute;\n  exports.utcHour = utcHour;\n  exports.utcDay = utcDay;\n  exports.utcSunday = utcSunday;\n  exports.utcMonday = utcMonday;\n  exports.utcTuesday = utcTuesday;\n  exports.utcWednesday = utcWednesday;\n  exports.utcThursday = utcThursday;\n  exports.utcFriday = utcFriday;\n  exports.utcSaturday = utcSaturday;\n  exports.utcWeek = utcSunday;\n  exports.utcMonth = utcMonth;\n  exports.utcYear = utcYear;\n  exports.interval = newInterval;\n\n}));",
    "var util = require('../util'),\n    time = require('../time'),\n    EPSILON = 1e-15;\n\nfunction bins(opt) {\n  if (!opt) { throw Error(\"Missing binning options.\"); }\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],\n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n\n    // increase step size if too many bins\n    while (Math.ceil(span/step) > maxb) { step *= base; }\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  if (!opt) { throw Error(\"Missing date binning options.\"); }\n\n  // find time step, then bin\n  var units = opt.utc ? time.utc : time,\n      dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n",
    "var util = require('./util'),\n    gen = module.exports;\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min === undefined ? 1 : min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    return (x >= min && x <= max) ? 1/d : 0;\n  };\n  f.cdf = function(x) {\n    return x < min ? 0 : x > max ? 1 : (x - min) / d;\n  };\n  f.icdf = function(p) {\n    return (p >= 0 && p <= 1) ? min + p*d : NaN;\n  };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    return (x === Math.floor(x) && x >= a && x < b) ? 1/d : 0;\n  };\n  f.cdf = function(x) {\n    var v = Math.floor(x);\n    return v < a ? 0 : v >= b ? 1 : (v - a + 1) / d;\n  };\n  f.icdf = function(p) {\n    return (p >= 0 && p <= 1) ? a - 1 + Math.floor(p*d) : NaN;\n  };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    var exp = Math.exp(Math.pow(x-mean, 2) / (-2 * Math.pow(stdev, 2)));\n    return (1 / (stdev * Math.sqrt(2*Math.PI))) * exp;\n  };\n  f.cdf = function(x) {\n    // Approximation from West (2009)\n    // Better Approximations to Cumulative Normal Functions\n    var cd,\n        z = (x - mean) / stdev,\n        Z = Math.abs(z);\n    if (Z > 37) {\n      cd = 0;\n    } else {\n      var sum, exp = Math.exp(-Z*Z/2);\n      if (Z < 7.07106781186547) {\n        sum = 3.52624965998911e-02 * Z + 0.700383064443688;\n        sum = sum * Z + 6.37396220353165;\n        sum = sum * Z + 33.912866078383;\n        sum = sum * Z + 112.079291497871;\n        sum = sum * Z + 221.213596169931;\n        sum = sum * Z + 220.206867912376;\n        cd = exp * sum;\n        sum = 8.83883476483184e-02 * Z + 1.75566716318264;\n        sum = sum * Z + 16.064177579207;\n        sum = sum * Z + 86.7807322029461;\n        sum = sum * Z + 296.564248779674;\n        sum = sum * Z + 637.333633378831;\n        sum = sum * Z + 793.826512519948;\n        sum = sum * Z + 440.413735824752;\n        cd = cd / sum;\n      } else {\n        sum = Z + 0.65;\n        sum = Z + 4 / sum;\n        sum = Z + 3 / sum;\n        sum = Z + 2 / sum;\n        sum = Z + 1 / sum;\n        cd = exp / sum / 2.506628274631;\n      }\n    }\n    return z > 0 ? 1 - cd : cd;\n  };\n  f.icdf = function(p) {\n    // Approximation of Probit function using inverse error function.\n    if (p <= 0 || p >= 1) return NaN;\n    var x = 2*p - 1,\n        v = (8 * (Math.PI - 3)) / (3 * Math.PI * (4-Math.PI)),\n        a = (2 / (Math.PI*v)) + (Math.log(1 - Math.pow(x,2)) / 2),\n        b = Math.log(1 - (x*x)) / v,\n        s = (x > 0 ? 1 : -1) * Math.sqrt(Math.sqrt((a*a) - b) - a);\n    return mean + stdev * Math.SQRT2 * s;\n  };\n  return f;\n};\n\ngen.random.bootstrap = function(domain, smooth) {\n  // Generates a bootstrap sample from a set of observations.\n  // Smooth bootstrapping adds random zero-centered noise to the samples.\n  var val = domain.filter(util.isValid),\n      len = val.length,\n      err = smooth ? gen.random.normal(0, smooth) : null;\n  var f = function() {\n    return val[~~(Math.random()*len)] + (err ? err() : 0);\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  return f;\n};",
    "var d3_time = require('d3-time');\n\nvar tempDate = new Date(),\n    baseDate = new Date(0, 0, 1).setFullYear(0), // Jan 1, 0 AD\n    utcBaseDate = new Date(Date.UTC(0, 0, 1)).setUTCFullYear(0);\n\nfunction date(d) {\n  return (tempDate.setTime(+d), tempDate);\n}\n\n// create a time unit entry\nfunction entry(type, date, unit, step, min, max) {\n  var e = {\n    type: type,\n    date: date,\n    unit: unit\n  };\n  if (step) {\n    e.step = step;\n  } else {\n    e.minstep = 1;\n  }\n  if (min != null) e.min = min;\n  if (max != null) e.max = max;\n  return e;\n}\n\nfunction create(type, unit, base, step, min, max) {\n  return entry(type,\n    function(d) { return unit.offset(base, d); },\n    function(d) { return unit.count(base, d); },\n    step, min, max);\n}\n\nvar locale = [\n  create('second', d3_time.second, baseDate),\n  create('minute', d3_time.minute, baseDate),\n  create('hour',   d3_time.hour,   baseDate),\n  create('day',    d3_time.day,    baseDate, [1, 7]),\n  create('month',  d3_time.month,  baseDate, [1, 3, 6]),\n  create('year',   d3_time.year,   baseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(1970, 0, 1, 0, 0, d); },\n    function(d) { return date(d).getSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(1970, 0, 1, 0, d); },\n    function(d) { return date(d).getMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(1970, 0, 1, d); },\n    function(d) { return date(d).getHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(1970, 0, 4+d); },\n    function(d) { return date(d).getDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(1970, 0, d); },\n    function(d) { return date(d).getDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(1970, d % 12, 1); },\n    function(d) { return date(d).getMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar utc = [\n  create('second', d3_time.utcSecond, utcBaseDate),\n  create('minute', d3_time.utcMinute, utcBaseDate),\n  create('hour',   d3_time.utcHour,   utcBaseDate),\n  create('day',    d3_time.utcDay,    utcBaseDate, [1, 7]),\n  create('month',  d3_time.utcMonth,  utcBaseDate, [1, 3, 6]),\n  create('year',   d3_time.utcYear,   utcBaseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, 0, d)); },\n    function(d) { return date(d).getUTCSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, d)); },\n    function(d) { return date(d).getUTCMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, d)); },\n    function(d) { return date(d).getUTCHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(Date.UTC(1970, 0, 4+d)); },\n    function(d) { return date(d).getUTCDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(Date.UTC(1970, 0, d)); },\n    function(d) { return date(d).getUTCDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(Date.UTC(1970, d % 12, 1)); },\n    function(d) { return date(d).getUTCMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction find(units, span, minb, maxb) {\n  var step = STEPS[0], i, n, bins;\n\n  for (i=1, n=STEPS.length; i<n; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return units[STEPS[i-1][1]];\n      }\n      if (bins >= minb) {\n        return units[step[1]];\n      }\n    }\n  }\n  return units[STEPS[n-1][1]];\n}\n\nfunction toUnitMap(units) {\n  var map = {}, i, n;\n  for (i=0, n=units.length; i<n; ++i) {\n    map[units[i].type] = units[i];\n  }\n  map.find = function(span, minb, maxb) {\n    return find(units, span, minb, maxb);\n  };\n  return map;\n}\n\nmodule.exports = toUnitMap(locale);\nmodule.exports.utc = toUnitMap(utc);",
    "var u = module.exports;\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && obj === obj;\n};\n\nu.isBuffer = (typeof Buffer === 'function' && Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\n// parse a date with optional d3.time-format format\nu.date = function(s, format) {\n  var d = format ? format : Date;\n  return s == null || s === '' ? null : d.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) || u.isString(x) ?\n      // Output valid JSON and JS source strings.\n      // See http://timelessrepo.com/json-isnt-a-javascript-subset\n      JSON.stringify(x).replace('\\u2028','\\\\u2028').replace('\\u2029', '\\\\u2029')\n    : x;\n};\n\n// data access functions\n\nvar field_re = /\\[(.*?)\\]|[^.\\[]+/g;\n\nu.field = function(f) {\n  return String(f).match(field_re).map(function(d) {\n    return d[0] !== '[' ? d :\n      d[1] !== \"'\" && d[1] !== '\"' ? d.slice(1, -1) :\n      d.slice(2, -2).replace(/\\\\([\"'])/g, '$1');\n  });\n};\n\nu.accessor = function(f) {\n  /* jshint evil: true */\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, Function('x', 'return x[' + u.field(f).map(u.str).join('][') + '];'));\n};\n\n// short-cut for accessor\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n",
    "var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');\n\nmodule.exports = function (obj, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var space = opts.space || '';\n    if (typeof space === 'number') space = Array(space+1).join(' ');\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n    var replacer = opts.replacer || function(key, value) { return value; };\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (parent, key, node, level) {\n        var indent = space ? ('\\n' + new Array(level + 1).join(space)) : '';\n        var colonSeparator = space ? ': ' : ':';\n\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        node = replacer.call(parent, key, node);\n\n        if (node === undefined) {\n            return;\n        }\n        if (typeof node !== 'object' || node === null) {\n            return json.stringify(node);\n        }\n        if (isArray(node)) {\n            var out = [];\n            for (var i = 0; i < node.length; i++) {\n                var item = stringify(node, i, node[i], level+1) || json.stringify(null);\n                out.push(indent + space + item);\n            }\n            return '[' + out.join(',') + indent + ']';\n        }\n        else {\n            if (seen.indexOf(node) !== -1) {\n                if (cycles) return json.stringify('__cycle__');\n                throw new TypeError('Converting circular structure to JSON');\n            }\n            else seen.push(node);\n\n            var keys = objectKeys(node).sort(cmp && cmp(node));\n            var out = [];\n            for (var i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                var value = stringify(node, key, node[key], level+1);\n\n                if(!value) continue;\n\n                var keyValue = json.stringify(key)\n                    + colonSeparator\n                    + value;\n                ;\n                out.push(indent + space + keyValue);\n            }\n            seen.splice(seen.indexOf(node), 1);\n            return '{' + out.join(',') + indent + '}';\n        }\n    })({ '': obj }, '', obj, 0);\n};\n\nvar isArray = Array.isArray || function (x) {\n    return {}.toString.call(x) === '[object Array]';\n};\n\nvar objectKeys = Object.keys || function (obj) {\n    var has = Object.prototype.hasOwnProperty || function () { return true };\n    var keys = [];\n    for (var key in obj) {\n        if (has.call(obj, key)) keys.push(key);\n    }\n    return keys;\n};\n",
    "exports.parse = require('./lib/parse');\nexports.stringify = require('./lib/stringify');\n",
    "var at, // The index of the current character\n    ch, // The current character\n    escapee = {\n        '\"':  '\"',\n        '\\\\': '\\\\',\n        '/':  '/',\n        b:    '\\b',\n        f:    '\\f',\n        n:    '\\n',\n        r:    '\\r',\n        t:    '\\t'\n    },\n    text,\n\n    error = function (m) {\n        // Call error when something is wrong.\n        throw {\n            name:    'SyntaxError',\n            message: m,\n            at:      at,\n            text:    text\n        };\n    },\n    \n    next = function (c) {\n        // If a c parameter is provided, verify that it matches the current character.\n        if (c && c !== ch) {\n            error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n        }\n        \n        // Get the next character. When there are no more characters,\n        // return the empty string.\n        \n        ch = text.charAt(at);\n        at += 1;\n        return ch;\n    },\n    \n    number = function () {\n        // Parse a number value.\n        var number,\n            string = '';\n        \n        if (ch === '-') {\n            string = '-';\n            next('-');\n        }\n        while (ch >= '0' && ch <= '9') {\n            string += ch;\n            next();\n        }\n        if (ch === '.') {\n            string += '.';\n            while (next() && ch >= '0' && ch <= '9') {\n                string += ch;\n            }\n        }\n        if (ch === 'e' || ch === 'E') {\n            string += ch;\n            next();\n            if (ch === '-' || ch === '+') {\n                string += ch;\n                next();\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n        }\n        number = +string;\n        if (!isFinite(number)) {\n            error(\"Bad number\");\n        } else {\n            return number;\n        }\n    },\n    \n    string = function () {\n        // Parse a string value.\n        var hex,\n            i,\n            string = '',\n            uffff;\n        \n        // When parsing for string values, we must look for \" and \\ characters.\n        if (ch === '\"') {\n            while (next()) {\n                if (ch === '\"') {\n                    next();\n                    return string;\n                } else if (ch === '\\\\') {\n                    next();\n                    if (ch === 'u') {\n                        uffff = 0;\n                        for (i = 0; i < 4; i += 1) {\n                            hex = parseInt(next(), 16);\n                            if (!isFinite(hex)) {\n                                break;\n                            }\n                            uffff = uffff * 16 + hex;\n                        }\n                        string += String.fromCharCode(uffff);\n                    } else if (typeof escapee[ch] === 'string') {\n                        string += escapee[ch];\n                    } else {\n                        break;\n                    }\n                } else {\n                    string += ch;\n                }\n            }\n        }\n        error(\"Bad string\");\n    },\n\n    white = function () {\n\n// Skip whitespace.\n\n        while (ch && ch <= ' ') {\n            next();\n        }\n    },\n\n    word = function () {\n\n// true, false, or null.\n\n        switch (ch) {\n        case 't':\n            next('t');\n            next('r');\n            next('u');\n            next('e');\n            return true;\n        case 'f':\n            next('f');\n            next('a');\n            next('l');\n            next('s');\n            next('e');\n            return false;\n        case 'n':\n            next('n');\n            next('u');\n            next('l');\n            next('l');\n            return null;\n        }\n        error(\"Unexpected '\" + ch + \"'\");\n    },\n\n    value,  // Place holder for the value function.\n\n    array = function () {\n\n// Parse an array value.\n\n        var array = [];\n\n        if (ch === '[') {\n            next('[');\n            white();\n            if (ch === ']') {\n                next(']');\n                return array;   // empty array\n            }\n            while (ch) {\n                array.push(value());\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad array\");\n    },\n\n    object = function () {\n\n// Parse an object value.\n\n        var key,\n            object = {};\n\n        if (ch === '{') {\n            next('{');\n            white();\n            if (ch === '}') {\n                next('}');\n                return object;   // empty object\n            }\n            while (ch) {\n                key = string();\n                white();\n                next(':');\n                if (Object.hasOwnProperty.call(object, key)) {\n                    error('Duplicate key \"' + key + '\"');\n                }\n                object[key] = value();\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad object\");\n    };\n\nvalue = function () {\n\n// Parse a JSON value. It could be an object, an array, a string, a number,\n// or a word.\n\n    white();\n    switch (ch) {\n    case '{':\n        return object();\n    case '[':\n        return array();\n    case '\"':\n        return string();\n    case '-':\n        return number();\n    default:\n        return ch >= '0' && ch <= '9' ? number() : word();\n    }\n};\n\n// Return the json_parse function. It will have access to all of the above\n// functions and variables.\n\nmodule.exports = function (source, reviver) {\n    var result;\n    \n    text = source;\n    at = 0;\n    ch = ' ';\n    result = value();\n    white();\n    if (ch) {\n        error(\"Syntax error\");\n    }\n\n    // If there is a reviver function, we recursively walk the new structure,\n    // passing each name/value pair to the reviver function for possible\n    // transformation, starting with a temporary root object that holds the result\n    // in an empty key. If there is not a reviver function, we simply return the\n    // result.\n\n    return typeof reviver === 'function' ? (function walk(holder, key) {\n        var k, v, value = holder[key];\n        if (value && typeof value === 'object') {\n            for (k in value) {\n                if (Object.prototype.hasOwnProperty.call(value, k)) {\n                    v = walk(value, k);\n                    if (v !== undefined) {\n                        value[k] = v;\n                    } else {\n                        delete value[k];\n                    }\n                }\n            }\n        }\n        return reviver.call(holder, key, value);\n    }({'': result}, '')) : result;\n};\n",
    "var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    gap,\n    indent,\n    meta = {    // table of character substitutions\n        '\\b': '\\\\b',\n        '\\t': '\\\\t',\n        '\\n': '\\\\n',\n        '\\f': '\\\\f',\n        '\\r': '\\\\r',\n        '\"' : '\\\\\"',\n        '\\\\': '\\\\\\\\'\n    },\n    rep;\n\nfunction quote(string) {\n    // If the string contains no control characters, no quote characters, and no\n    // backslash characters, then we can safely slap some quotes around it.\n    // Otherwise we must also replace the offending characters with safe escape\n    // sequences.\n    \n    escapable.lastIndex = 0;\n    return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n        var c = meta[a];\n        return typeof c === 'string' ? c :\n            '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n    }) + '\"' : '\"' + string + '\"';\n}\n\nfunction str(key, holder) {\n    // Produce a string from holder[key].\n    var i,          // The loop counter.\n        k,          // The member key.\n        v,          // The member value.\n        length,\n        mind = gap,\n        partial,\n        value = holder[key];\n    \n    // If the value has a toJSON method, call it to obtain a replacement value.\n    if (value && typeof value === 'object' &&\n            typeof value.toJSON === 'function') {\n        value = value.toJSON(key);\n    }\n    \n    // If we were called with a replacer function, then call the replacer to\n    // obtain a replacement value.\n    if (typeof rep === 'function') {\n        value = rep.call(holder, key, value);\n    }\n    \n    // What happens next depends on the value's type.\n    switch (typeof value) {\n        case 'string':\n            return quote(value);\n        \n        case 'number':\n            // JSON numbers must be finite. Encode non-finite numbers as null.\n            return isFinite(value) ? String(value) : 'null';\n        \n        case 'boolean':\n        case 'null':\n            // If the value is a boolean or null, convert it to a string. Note:\n            // typeof null does not produce 'null'. The case is included here in\n            // the remote chance that this gets fixed someday.\n            return String(value);\n            \n        case 'object':\n            if (!value) return 'null';\n            gap += indent;\n            partial = [];\n            \n            // Array.isArray\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || 'null';\n                }\n                \n                // Join all of the elements together, separated with commas, and\n                // wrap them in brackets.\n                v = partial.length === 0 ? '[]' : gap ?\n                    '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n                    '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n            }\n            \n            // If the replacer is an array, use it to select the members to be\n            // stringified.\n            if (rep && typeof rep === 'object') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    k = rep[i];\n                    if (typeof k === 'string') {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            else {\n                // Otherwise, iterate through all of the keys in the object.\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            \n        // Join all of the member texts together, separated with commas,\n        // and wrap them in braces.\n\n        v = partial.length === 0 ? '{}' : gap ?\n            '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n            '{' + partial.join(',') + '}';\n        gap = mind;\n        return v;\n    }\n}\n\nmodule.exports = function (value, replacer, space) {\n    var i;\n    gap = '';\n    indent = '';\n    \n    // If the space parameter is a number, make an indent string containing that\n    // many spaces.\n    if (typeof space === 'number') {\n        for (i = 0; i < space; i += 1) {\n            indent += ' ';\n        }\n    }\n    // If the space parameter is a string, it will be used as the indent string.\n    else if (typeof space === 'string') {\n        indent = space;\n    }\n\n    // If there is a replacer, it must be a function or an array.\n    // Otherwise, throw an error.\n    rep = replacer;\n    if (replacer && typeof replacer !== 'function'\n    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {\n        throw new Error('JSON.stringify');\n    }\n    \n    // Make a fake root object containing our value under the key of ''.\n    // Return the result of stringifying the value.\n    return str('', {'': value});\n};\n",
    "\"use strict\";\n(function (AggregateOp) {\n    AggregateOp[AggregateOp[\"VALUES\"] = 'values'] = \"VALUES\";\n    AggregateOp[AggregateOp[\"COUNT\"] = 'count'] = \"COUNT\";\n    AggregateOp[AggregateOp[\"VALID\"] = 'valid'] = \"VALID\";\n    AggregateOp[AggregateOp[\"MISSING\"] = 'missing'] = \"MISSING\";\n    AggregateOp[AggregateOp[\"DISTINCT\"] = 'distinct'] = \"DISTINCT\";\n    AggregateOp[AggregateOp[\"SUM\"] = 'sum'] = \"SUM\";\n    AggregateOp[AggregateOp[\"MEAN\"] = 'mean'] = \"MEAN\";\n    AggregateOp[AggregateOp[\"AVERAGE\"] = 'average'] = \"AVERAGE\";\n    AggregateOp[AggregateOp[\"VARIANCE\"] = 'variance'] = \"VARIANCE\";\n    AggregateOp[AggregateOp[\"VARIANCEP\"] = 'variancep'] = \"VARIANCEP\";\n    AggregateOp[AggregateOp[\"STDEV\"] = 'stdev'] = \"STDEV\";\n    AggregateOp[AggregateOp[\"STDEVP\"] = 'stdevp'] = \"STDEVP\";\n    AggregateOp[AggregateOp[\"MEDIAN\"] = 'median'] = \"MEDIAN\";\n    AggregateOp[AggregateOp[\"Q1\"] = 'q1'] = \"Q1\";\n    AggregateOp[AggregateOp[\"Q3\"] = 'q3'] = \"Q3\";\n    AggregateOp[AggregateOp[\"MODESKEW\"] = 'modeskew'] = \"MODESKEW\";\n    AggregateOp[AggregateOp[\"MIN\"] = 'min'] = \"MIN\";\n    AggregateOp[AggregateOp[\"MAX\"] = 'max'] = \"MAX\";\n    AggregateOp[AggregateOp[\"ARGMIN\"] = 'argmin'] = \"ARGMIN\";\n    AggregateOp[AggregateOp[\"ARGMAX\"] = 'argmax'] = \"ARGMAX\";\n})(exports.AggregateOp || (exports.AggregateOp = {}));\nvar AggregateOp = exports.AggregateOp;\nexports.AGGREGATE_OPS = [\n    AggregateOp.VALUES,\n    AggregateOp.COUNT,\n    AggregateOp.VALID,\n    AggregateOp.MISSING,\n    AggregateOp.DISTINCT,\n    AggregateOp.SUM,\n    AggregateOp.MEAN,\n    AggregateOp.AVERAGE,\n    AggregateOp.VARIANCE,\n    AggregateOp.VARIANCEP,\n    AggregateOp.STDEV,\n    AggregateOp.STDEVP,\n    AggregateOp.MEDIAN,\n    AggregateOp.Q1,\n    AggregateOp.Q3,\n    AggregateOp.MODESKEW,\n    AggregateOp.MIN,\n    AggregateOp.MAX,\n    AggregateOp.ARGMIN,\n    AggregateOp.ARGMAX,\n];\nexports.SUM_OPS = [\n    AggregateOp.COUNT,\n    AggregateOp.SUM,\n    AggregateOp.DISTINCT\n];\nexports.SHARED_DOMAIN_OPS = [\n    AggregateOp.MEAN,\n    AggregateOp.AVERAGE,\n    AggregateOp.STDEV,\n    AggregateOp.STDEVP,\n    AggregateOp.MEDIAN,\n    AggregateOp.Q1,\n    AggregateOp.Q3,\n    AggregateOp.MIN,\n    AggregateOp.MAX,\n];\n//# sourceMappingURL=aggregate.js.map",
    "\"use strict\";\n(function (AxisOrient) {\n    AxisOrient[AxisOrient[\"TOP\"] = 'top'] = \"TOP\";\n    AxisOrient[AxisOrient[\"RIGHT\"] = 'right'] = \"RIGHT\";\n    AxisOrient[AxisOrient[\"LEFT\"] = 'left'] = \"LEFT\";\n    AxisOrient[AxisOrient[\"BOTTOM\"] = 'bottom'] = \"BOTTOM\";\n})(exports.AxisOrient || (exports.AxisOrient = {}));\nvar AxisOrient = exports.AxisOrient;\nexports.defaultAxisConfig = {\n    offset: undefined,\n    grid: undefined,\n    labels: true,\n    labelMaxLength: 25,\n    tickSize: undefined,\n    characterWidth: 6\n};\nexports.defaultFacetAxisConfig = {\n    axisWidth: 0,\n    labels: true,\n    grid: false,\n    tickSize: 0\n};\n//# sourceMappingURL=axis.js.map",
    "\"use strict\";\nvar util_1 = require('./util');\n(function (Channel) {\n    Channel[Channel[\"X\"] = 'x'] = \"X\";\n    Channel[Channel[\"Y\"] = 'y'] = \"Y\";\n    Channel[Channel[\"X2\"] = 'x2'] = \"X2\";\n    Channel[Channel[\"Y2\"] = 'y2'] = \"Y2\";\n    Channel[Channel[\"ROW\"] = 'row'] = \"ROW\";\n    Channel[Channel[\"COLUMN\"] = 'column'] = \"COLUMN\";\n    Channel[Channel[\"SHAPE\"] = 'shape'] = \"SHAPE\";\n    Channel[Channel[\"SIZE\"] = 'size'] = \"SIZE\";\n    Channel[Channel[\"COLOR\"] = 'color'] = \"COLOR\";\n    Channel[Channel[\"TEXT\"] = 'text'] = \"TEXT\";\n    Channel[Channel[\"DETAIL\"] = 'detail'] = \"DETAIL\";\n    Channel[Channel[\"LABEL\"] = 'label'] = \"LABEL\";\n    Channel[Channel[\"PATH\"] = 'path'] = \"PATH\";\n    Channel[Channel[\"ORDER\"] = 'order'] = \"ORDER\";\n    Channel[Channel[\"OPACITY\"] = 'opacity'] = \"OPACITY\";\n    Channel[Channel[\"GEOPATH\"] = 'geopath'] = \"GEOPATH\";\n})(exports.Channel || (exports.Channel = {}));\nvar Channel = exports.Channel;\nexports.X = Channel.X;\nexports.Y = Channel.Y;\nexports.X2 = Channel.X2;\nexports.Y2 = Channel.Y2;\nexports.ROW = Channel.ROW;\nexports.COLUMN = Channel.COLUMN;\nexports.SHAPE = Channel.SHAPE;\nexports.SIZE = Channel.SIZE;\nexports.COLOR = Channel.COLOR;\nexports.TEXT = Channel.TEXT;\nexports.DETAIL = Channel.DETAIL;\nexports.LABEL = Channel.LABEL;\nexports.PATH = Channel.PATH;\nexports.ORDER = Channel.ORDER;\nexports.OPACITY = Channel.OPACITY;\nexports.GEOPATH = Channel.GEOPATH;\nexports.CHANNELS = [exports.X, exports.Y, exports.X2, exports.Y2, exports.ROW, exports.COLUMN,\n    exports.SIZE, exports.SHAPE, exports.COLOR, exports.OPACITY,\n    exports.PATH, exports.ORDER, exports.TEXT, exports.DETAIL, exports.LABEL,\n    exports.GEOPATH];\nexports.UNIT_CHANNELS = util_1.without(exports.CHANNELS, [exports.ROW, exports.COLUMN]);\nexports.UNIT_SCALE_CHANNELS = util_1.without(exports.UNIT_CHANNELS, [exports.PATH, exports.ORDER, exports.DETAIL, exports.TEXT, exports.LABEL, exports.X2, exports.Y2]);\nexports.NONSPATIAL_CHANNELS = util_1.without(exports.UNIT_CHANNELS, [exports.X, exports.Y, exports.X2, exports.Y2]);\nexports.NONSPATIAL_SCALE_CHANNELS = util_1.without(exports.UNIT_SCALE_CHANNELS, [exports.X, exports.Y, exports.X2, exports.Y2]);\nexports.STACK_GROUP_CHANNELS = [exports.COLOR, exports.DETAIL, exports.ORDER, exports.OPACITY, exports.SIZE];\n;\nfunction supportMark(channel, mark) {\n    return !!getSupportedMark(channel)[mark];\n}\nexports.supportMark = supportMark;\nfunction getSupportedMark(channel) {\n    switch (channel) {\n        case exports.X:\n        case exports.Y:\n        case exports.COLOR:\n        case exports.DETAIL:\n        case exports.ORDER:\n        case exports.OPACITY:\n        case exports.ROW:\n        case exports.COLUMN:\n            return {\n                point: true, tick: true, rule: true, circle: true, square: true,\n                bar: true, line: true, area: true, text: true\n            };\n        case exports.X2:\n        case exports.Y2:\n            return {\n                rule: true, bar: true, area: true\n            };\n        case exports.SIZE:\n            return {\n                point: true, tick: true, rule: true, circle: true, square: true,\n                bar: true, text: true\n            };\n        case exports.SHAPE:\n            return { point: true };\n        case exports.TEXT:\n            return { text: true };\n        case exports.PATH:\n            return { line: true };\n        case exports.GEOPATH:\n            return { path: true };\n    }\n    return {};\n}\nexports.getSupportedMark = getSupportedMark;\n;\nfunction getSupportedRole(channel) {\n    switch (channel) {\n        case exports.X:\n        case exports.Y:\n        case exports.COLOR:\n        case exports.OPACITY:\n        case exports.LABEL:\n        case exports.DETAIL:\n            return {\n                measure: true,\n                dimension: true\n            };\n        case exports.ROW:\n        case exports.COLUMN:\n        case exports.SHAPE:\n            return {\n                measure: false,\n                dimension: true\n            };\n        case exports.X2:\n        case exports.Y2:\n        case exports.SIZE:\n        case exports.TEXT:\n            return {\n                measure: true,\n                dimension: false\n            };\n        case exports.PATH:\n            return {\n                measure: false,\n                dimension: true\n            };\n        case exports.GEOPATH:\n            return {\n                measure: false,\n                dimension: true\n            };\n    }\n    throw new Error('Invalid encoding channel' + channel);\n}\nexports.getSupportedRole = getSupportedRole;\nfunction hasScale(channel) {\n    return !util_1.contains([exports.DETAIL, exports.PATH, exports.TEXT, exports.LABEL, exports.ORDER], channel);\n}\nexports.hasScale = hasScale;\n//# sourceMappingURL=channel.js.map",
    "\"use strict\";\nvar scale_1 = require('./scale');\nvar axis_1 = require('./axis');\nvar legend_1 = require('./legend');\nexports.defaultCellConfig = {\n    width: 200,\n    height: 200\n};\nexports.defaultFacetCellConfig = {\n    stroke: '#ccc',\n    strokeWidth: 1\n};\nvar defaultFacetGridConfig = {\n    color: '#000000',\n    opacity: 0.4,\n    offset: 0\n};\nvar defaultProjectionConfig = {\n    type: 'mercator'\n};\nexports.defaultFacetConfig = {\n    scale: scale_1.defaultFacetScaleConfig,\n    axis: axis_1.defaultFacetAxisConfig,\n    grid: defaultFacetGridConfig,\n    cell: exports.defaultFacetCellConfig\n};\n(function (FontWeight) {\n    FontWeight[FontWeight[\"NORMAL\"] = 'normal'] = \"NORMAL\";\n    FontWeight[FontWeight[\"BOLD\"] = 'bold'] = \"BOLD\";\n})(exports.FontWeight || (exports.FontWeight = {}));\nvar FontWeight = exports.FontWeight;\n(function (Shape) {\n    Shape[Shape[\"CIRCLE\"] = 'circle'] = \"CIRCLE\";\n    Shape[Shape[\"SQUARE\"] = 'square'] = \"SQUARE\";\n    Shape[Shape[\"CROSS\"] = 'cross'] = \"CROSS\";\n    Shape[Shape[\"DIAMOND\"] = 'diamond'] = \"DIAMOND\";\n    Shape[Shape[\"TRIANGLEUP\"] = 'triangle-up'] = \"TRIANGLEUP\";\n    Shape[Shape[\"TRIANGLEDOWN\"] = 'triangle-down'] = \"TRIANGLEDOWN\";\n})(exports.Shape || (exports.Shape = {}));\nvar Shape = exports.Shape;\n(function (HorizontalAlign) {\n    HorizontalAlign[HorizontalAlign[\"LEFT\"] = 'left'] = \"LEFT\";\n    HorizontalAlign[HorizontalAlign[\"RIGHT\"] = 'right'] = \"RIGHT\";\n    HorizontalAlign[HorizontalAlign[\"CENTER\"] = 'center'] = \"CENTER\";\n})(exports.HorizontalAlign || (exports.HorizontalAlign = {}));\nvar HorizontalAlign = exports.HorizontalAlign;\n(function (VerticalAlign) {\n    VerticalAlign[VerticalAlign[\"TOP\"] = 'top'] = \"TOP\";\n    VerticalAlign[VerticalAlign[\"MIDDLE\"] = 'middle'] = \"MIDDLE\";\n    VerticalAlign[VerticalAlign[\"BOTTOM\"] = 'bottom'] = \"BOTTOM\";\n})(exports.VerticalAlign || (exports.VerticalAlign = {}));\nvar VerticalAlign = exports.VerticalAlign;\n(function (FontStyle) {\n    FontStyle[FontStyle[\"NORMAL\"] = 'normal'] = \"NORMAL\";\n    FontStyle[FontStyle[\"ITALIC\"] = 'italic'] = \"ITALIC\";\n})(exports.FontStyle || (exports.FontStyle = {}));\nvar FontStyle = exports.FontStyle;\n(function (Interpolate) {\n    Interpolate[Interpolate[\"LINEAR\"] = 'linear'] = \"LINEAR\";\n    Interpolate[Interpolate[\"LINEAR_CLOSED\"] = 'linear-closed'] = \"LINEAR_CLOSED\";\n    Interpolate[Interpolate[\"STEP\"] = 'step'] = \"STEP\";\n    Interpolate[Interpolate[\"STEP_BEFORE\"] = 'step-before'] = \"STEP_BEFORE\";\n    Interpolate[Interpolate[\"STEP_AFTER\"] = 'step-after'] = \"STEP_AFTER\";\n    Interpolate[Interpolate[\"BASIS\"] = 'basis'] = \"BASIS\";\n    Interpolate[Interpolate[\"BASIS_OPEN\"] = 'basis-open'] = \"BASIS_OPEN\";\n    Interpolate[Interpolate[\"BASIS_CLOSED\"] = 'basis-closed'] = \"BASIS_CLOSED\";\n    Interpolate[Interpolate[\"CARDINAL\"] = 'cardinal'] = \"CARDINAL\";\n    Interpolate[Interpolate[\"CARDINAL_OPEN\"] = 'cardinal-open'] = \"CARDINAL_OPEN\";\n    Interpolate[Interpolate[\"CARDINAL_CLOSED\"] = 'cardinal-closed'] = \"CARDINAL_CLOSED\";\n    Interpolate[Interpolate[\"BUNDLE\"] = 'bundle'] = \"BUNDLE\";\n    Interpolate[Interpolate[\"MONOTONE\"] = 'monotone'] = \"MONOTONE\";\n})(exports.Interpolate || (exports.Interpolate = {}));\nvar Interpolate = exports.Interpolate;\n(function (AreaOverlay) {\n    AreaOverlay[AreaOverlay[\"LINE\"] = 'line'] = \"LINE\";\n    AreaOverlay[AreaOverlay[\"LINEPOINT\"] = 'linepoint'] = \"LINEPOINT\";\n    AreaOverlay[AreaOverlay[\"NONE\"] = 'none'] = \"NONE\";\n})(exports.AreaOverlay || (exports.AreaOverlay = {}));\nvar AreaOverlay = exports.AreaOverlay;\nexports.defaultOverlayConfig = {\n    line: false,\n    pointStyle: { filled: true },\n    lineStyle: {}\n};\nexports.defaultMarkConfig = {\n    color: '#4682b4',\n    shape: Shape.CIRCLE,\n    strokeWidth: 2,\n    size: 30,\n    barThinSize: 2,\n    ruleSize: 1,\n    tickThickness: 1,\n    fontSize: 10,\n    baseline: VerticalAlign.MIDDLE,\n    text: 'Abc',\n    shortTimeLabels: false,\n    applyColorToBackground: false\n};\nexports.defaultConfig = {\n    numberFormat: 's',\n    timeFormat: '%Y-%m-%d',\n    cell: exports.defaultCellConfig,\n    mark: exports.defaultMarkConfig,\n    overlay: exports.defaultOverlayConfig,\n    scale: scale_1.defaultScaleConfig,\n    axis: axis_1.defaultAxisConfig,\n    legend: legend_1.defaultLegendConfig,\n    projection: defaultProjectionConfig,\n    facet: exports.defaultFacetConfig,\n};\n//# sourceMappingURL=config.js.map",
    "\"use strict\";\nvar channel_1 = require('./channel');\nvar type_1 = require('./type');\nvar util_1 = require('./util');\nfunction countRetinal(encoding) {\n    var count = 0;\n    if (encoding.color) {\n        count++;\n    }\n    if (encoding.opacity) {\n        count++;\n    }\n    if (encoding.size) {\n        count++;\n    }\n    if (encoding.shape) {\n        count++;\n    }\n    return count;\n}\nexports.countRetinal = countRetinal;\nfunction channels(encoding) {\n    return channel_1.CHANNELS.filter(function (channel) {\n        return has(encoding, channel);\n    });\n}\nexports.channels = channels;\nfunction hasChannelField(encoding, channel) {\n    var channelEncoding = encoding && encoding[channel];\n    return channelEncoding && (channelEncoding.field !== undefined ||\n        (util_1.isArray(channelEncoding) && channelEncoding.length > 0));\n}\nexports.hasChannelField = hasChannelField;\nfunction has(encoding, channel) {\n    var channelEncoding = encoding && encoding[channel];\n    return channelEncoding && (channelEncoding.field !== undefined ||\n        (util_1.isArray(channelEncoding) && channelEncoding.length > 0));\n}\nexports.has = has;\nfunction isAggregate(encoding) {\n    return util_1.some(channel_1.CHANNELS, function (channel) {\n        if (has(encoding, channel) && encoding[channel].aggregate) {\n            return true;\n        }\n        return false;\n    });\n}\nexports.isAggregate = isAggregate;\nfunction isRanged(encoding) {\n    return encoding && ((!!encoding.x && !!encoding.x2) || (!!encoding.y && !!encoding.y2));\n}\nexports.isRanged = isRanged;\nfunction fieldDefs(encoding) {\n    var arr = [];\n    channel_1.CHANNELS.forEach(function (channel) {\n        if (has(encoding, channel)) {\n            if (util_1.isArray(encoding[channel])) {\n                encoding[channel].forEach(function (fieldDef) {\n                    arr.push(fieldDef);\n                });\n            }\n            else {\n                arr.push(encoding[channel]);\n            }\n        }\n    });\n    return arr;\n}\nexports.fieldDefs = fieldDefs;\n;\nfunction forEach(encoding, f, thisArg) {\n    channelMappingForEach(channel_1.CHANNELS, encoding, f, thisArg);\n}\nexports.forEach = forEach;\nfunction channelMappingForEach(channels, mapping, f, thisArg) {\n    var i = 0;\n    channels.forEach(function (channel) {\n        if (has(mapping, channel)) {\n            if (util_1.isArray(mapping[channel])) {\n                mapping[channel].forEach(function (fieldDef) {\n                    f.call(thisArg, fieldDef, channel, i++);\n                });\n            }\n            else {\n                f.call(thisArg, mapping[channel], channel, i++);\n            }\n        }\n    });\n}\nexports.channelMappingForEach = channelMappingForEach;\nfunction map(encoding, f, thisArg) {\n    return channelMappingMap(channel_1.CHANNELS, encoding, f, thisArg);\n}\nexports.map = map;\nfunction channelMappingMap(channels, mapping, f, thisArg) {\n    var arr = [];\n    channels.forEach(function (channel) {\n        if (has(mapping, channel)) {\n            if (util_1.isArray(mapping[channel])) {\n                mapping[channel].forEach(function (fieldDef) {\n                    arr.push(f.call(thisArg, fieldDef, channel));\n                });\n            }\n            else {\n                arr.push(f.call(thisArg, mapping[channel], channel));\n            }\n        }\n    });\n    return arr;\n}\nexports.channelMappingMap = channelMappingMap;\nfunction reduce(encoding, f, init, thisArg) {\n    return channelMappingReduce(channel_1.CHANNELS, encoding, f, init, thisArg);\n}\nexports.reduce = reduce;\nfunction channelMappingReduce(channels, mapping, f, init, thisArg) {\n    var r = init;\n    channel_1.CHANNELS.forEach(function (channel) {\n        if (has(mapping, channel)) {\n            if (util_1.isArray(mapping[channel])) {\n                mapping[channel].forEach(function (fieldDef) {\n                    r = f.call(thisArg, r, fieldDef, channel);\n                });\n            }\n            else {\n                r = f.call(thisArg, r, mapping[channel], channel);\n            }\n        }\n    });\n    return r;\n}\nexports.channelMappingReduce = channelMappingReduce;\nfunction containsLatLong(encoding) {\n    if (encoding.x) {\n        var xType = encoding.x.type;\n        if (xType === type_1.LATITUDE || xType === type_1.LONGITUDE) {\n            return true;\n        }\n    }\n    else if (encoding.y) {\n        var yType = encoding.y.type;\n        if (yType === type_1.LATITUDE || yType === type_1.LONGITUDE) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.containsLatLong = containsLatLong;\n//# sourceMappingURL=encoding.js.map",
    "\"use strict\";\nvar aggregate_1 = require('./aggregate');\nvar scale_1 = require('./scale');\nvar timeunit_1 = require('./timeunit');\nvar type_1 = require('./type');\nvar util_1 = require('./util');\nexports.aggregate = {\n    type: 'string',\n    enum: aggregate_1.AGGREGATE_OPS,\n    supportedEnums: {\n        quantitative: aggregate_1.AGGREGATE_OPS,\n        ordinal: ['median', 'min', 'max'],\n        nominal: [],\n        temporal: ['mean', 'median', 'min', 'max'],\n        '': ['count']\n    },\n    supportedTypes: util_1.toMap([type_1.QUANTITATIVE, type_1.NOMINAL, type_1.ORDINAL, type_1.TEMPORAL, ''])\n};\nfunction field(fieldDef, opt) {\n    if (opt === void 0) { opt = {}; }\n    var prefix = (opt.datum ? 'datum.' : '') + (opt.prefn || '');\n    var suffix = opt.suffix || '';\n    var field = fieldDef.field;\n    if (isCount(fieldDef)) {\n        return prefix + 'count' + suffix;\n    }\n    else if (opt.fn) {\n        return prefix + opt.fn + '_' + field + suffix;\n    }\n    else if (!opt.nofn && fieldDef.bin) {\n        var binSuffix = opt.binSuffix || (opt.scaleType === scale_1.ScaleType.ORDINAL ?\n            '_range' :\n            '_start');\n        return prefix + 'bin_' + field + binSuffix;\n    }\n    else if (!opt.nofn && !opt.noAggregate && fieldDef.aggregate) {\n        return prefix + fieldDef.aggregate + '_' + field + suffix;\n    }\n    else if (!opt.nofn && fieldDef.timeUnit) {\n        return prefix + fieldDef.timeUnit + '_' + field + suffix;\n    }\n    else if (fieldDef.type === type_1.LATITUDE) {\n        return prefix + 'layout_y';\n    }\n    else if (fieldDef.type === type_1.LONGITUDE) {\n        return prefix + 'layout_x';\n    }\n    else if (fieldDef.type === type_1.GEOJSON) {\n        return prefix + 'layout_path';\n    }\n    else {\n        return prefix + field;\n    }\n}\nexports.field = field;\nfunction _isFieldDimension(fieldDef) {\n    return util_1.contains([type_1.NOMINAL, type_1.ORDINAL], fieldDef.type) || !!fieldDef.bin ||\n        (fieldDef.type === type_1.TEMPORAL && !!fieldDef.timeUnit);\n}\nfunction isDimension(fieldDef) {\n    return fieldDef && fieldDef.field && _isFieldDimension(fieldDef);\n}\nexports.isDimension = isDimension;\nfunction isMeasure(fieldDef) {\n    return fieldDef && fieldDef.field && !_isFieldDimension(fieldDef);\n}\nexports.isMeasure = isMeasure;\nexports.COUNT_TITLE = 'Number of Records';\nfunction count() {\n    return { field: '*', aggregate: aggregate_1.AggregateOp.COUNT, type: type_1.QUANTITATIVE, title: exports.COUNT_TITLE };\n}\nexports.count = count;\nfunction isCount(fieldDef) {\n    return fieldDef.aggregate === aggregate_1.AggregateOp.COUNT;\n}\nexports.isCount = isCount;\nfunction cardinality(fieldDef, stats, filterNull) {\n    if (filterNull === void 0) { filterNull = {}; }\n    var stat = stats[fieldDef.field], type = fieldDef.type;\n    if (fieldDef.bin) {\n        var bin_1 = fieldDef.bin;\n        var maxbins = (typeof bin_1 === 'boolean') ? undefined : bin_1.maxbins;\n        if (maxbins === undefined) {\n            maxbins = 10;\n        }\n        var bins = util_1.getbins(stat, maxbins);\n        return (bins.stop - bins.start) / bins.step;\n    }\n    if (type === type_1.TEMPORAL) {\n        var timeUnit = fieldDef.timeUnit;\n        switch (timeUnit) {\n            case timeunit_1.TimeUnit.SECONDS: return 60;\n            case timeunit_1.TimeUnit.MINUTES: return 60;\n            case timeunit_1.TimeUnit.HOURS: return 24;\n            case timeunit_1.TimeUnit.DAY: return 7;\n            case timeunit_1.TimeUnit.DATE: return 31;\n            case timeunit_1.TimeUnit.MONTH: return 12;\n            case timeunit_1.TimeUnit.QUARTER: return 4;\n            case timeunit_1.TimeUnit.YEAR:\n                var yearstat = stats['year_' + fieldDef.field];\n                if (!yearstat) {\n                    return null;\n                }\n                return yearstat.distinct -\n                    (stat.missing > 0 && filterNull[type] ? 1 : 0);\n        }\n    }\n    if (fieldDef.aggregate) {\n        return 1;\n    }\n    return stat.distinct -\n        (stat.missing > 0 && filterNull[type] ? 1 : 0);\n}\nexports.cardinality = cardinality;\nfunction title(fieldDef) {\n    if (fieldDef.title != null) {\n        return fieldDef.title;\n    }\n    if (isCount(fieldDef)) {\n        return exports.COUNT_TITLE;\n    }\n    var fn = fieldDef.aggregate || fieldDef.timeUnit || (fieldDef.bin && 'bin');\n    if (fn) {\n        return fn.toString().toUpperCase() + '(' + fieldDef.field + ')';\n    }\n    else {\n        return fieldDef.field;\n    }\n}\nexports.title = title;\n//# sourceMappingURL=fielddef.js.map",
    "\"use strict\";\nexports.defaultLegendConfig = {\n    orient: undefined,\n    shortTimeLabels: false\n};\n//# sourceMappingURL=legend.js.map",
    "\"use strict\";\n(function (Mark) {\n    Mark[Mark[\"AREA\"] = 'area'] = \"AREA\";\n    Mark[Mark[\"BAR\"] = 'bar'] = \"BAR\";\n    Mark[Mark[\"LINE\"] = 'line'] = \"LINE\";\n    Mark[Mark[\"POINT\"] = 'point'] = \"POINT\";\n    Mark[Mark[\"TEXT\"] = 'text'] = \"TEXT\";\n    Mark[Mark[\"TICK\"] = 'tick'] = \"TICK\";\n    Mark[Mark[\"RULE\"] = 'rule'] = \"RULE\";\n    Mark[Mark[\"CIRCLE\"] = 'circle'] = \"CIRCLE\";\n    Mark[Mark[\"SQUARE\"] = 'square'] = \"SQUARE\";\n    Mark[Mark[\"PATH\"] = 'path'] = \"PATH\";\n    Mark[Mark[\"ERRORBAR\"] = 'errorBar'] = \"ERRORBAR\";\n})(exports.Mark || (exports.Mark = {}));\nvar Mark = exports.Mark;\nexports.AREA = Mark.AREA;\nexports.BAR = Mark.BAR;\nexports.LINE = Mark.LINE;\nexports.POINT = Mark.POINT;\nexports.TEXT = Mark.TEXT;\nexports.TICK = Mark.TICK;\nexports.RULE = Mark.RULE;\nexports.PATH = Mark.PATH;\nexports.CIRCLE = Mark.CIRCLE;\nexports.SQUARE = Mark.SQUARE;\nexports.ERRORBAR = Mark.ERRORBAR;\nexports.PRIMITIVE_MARKS = [exports.AREA, exports.BAR, exports.LINE, exports.POINT, exports.TEXT, exports.TICK, exports.RULE, exports.CIRCLE, exports.SQUARE];\n//# sourceMappingURL=mark.js.map",
    "\"use strict\";\n(function (ScaleType) {\n    ScaleType[ScaleType[\"LINEAR\"] = 'linear'] = \"LINEAR\";\n    ScaleType[ScaleType[\"LOG\"] = 'log'] = \"LOG\";\n    ScaleType[ScaleType[\"POW\"] = 'pow'] = \"POW\";\n    ScaleType[ScaleType[\"SQRT\"] = 'sqrt'] = \"SQRT\";\n    ScaleType[ScaleType[\"QUANTILE\"] = 'quantile'] = \"QUANTILE\";\n    ScaleType[ScaleType[\"QUANTIZE\"] = 'quantize'] = \"QUANTIZE\";\n    ScaleType[ScaleType[\"ORDINAL\"] = 'ordinal'] = \"ORDINAL\";\n    ScaleType[ScaleType[\"TIME\"] = 'time'] = \"TIME\";\n    ScaleType[ScaleType[\"UTC\"] = 'utc'] = \"UTC\";\n})(exports.ScaleType || (exports.ScaleType = {}));\nvar ScaleType = exports.ScaleType;\n(function (NiceTime) {\n    NiceTime[NiceTime[\"SECOND\"] = 'second'] = \"SECOND\";\n    NiceTime[NiceTime[\"MINUTE\"] = 'minute'] = \"MINUTE\";\n    NiceTime[NiceTime[\"HOUR\"] = 'hour'] = \"HOUR\";\n    NiceTime[NiceTime[\"DAY\"] = 'day'] = \"DAY\";\n    NiceTime[NiceTime[\"WEEK\"] = 'week'] = \"WEEK\";\n    NiceTime[NiceTime[\"MONTH\"] = 'month'] = \"MONTH\";\n    NiceTime[NiceTime[\"YEAR\"] = 'year'] = \"YEAR\";\n})(exports.NiceTime || (exports.NiceTime = {}));\nvar NiceTime = exports.NiceTime;\nexports.defaultScaleConfig = {\n    round: true,\n    textBandWidth: 90,\n    bandSize: 21,\n    padding: 1,\n    useRawDomain: false,\n    opacity: [0.3, 0.8],\n    nominalColorRange: 'category10',\n    sequentialColorRange: ['#AFC6A3', '#09622A'],\n    shapeRange: 'shapes',\n    fontSizeRange: [8, 40],\n    ruleSizeRange: [1, 5],\n    tickSizeRange: [1, 20]\n};\nexports.defaultFacetScaleConfig = {\n    round: true,\n    padding: 16\n};\n//# sourceMappingURL=scale.js.map",
    "\"use strict\";\nvar aggregate_1 = require('./aggregate');\nvar timeunit_1 = require('./timeunit');\nvar type_1 = require('./type');\nvar vlEncoding = require('./encoding');\nvar mark_1 = require('./mark');\nexports.DELIM = '|';\nexports.ASSIGN = '=';\nexports.TYPE = ',';\nexports.FUNC = '_';\nfunction shorten(spec) {\n    return 'mark' + exports.ASSIGN + spec.mark +\n        exports.DELIM + shortenEncoding(spec.encoding);\n}\nexports.shorten = shorten;\nfunction parse(shorthand, data, config) {\n    var split = shorthand.split(exports.DELIM), mark = split.shift().split(exports.ASSIGN)[1].trim(), encoding = parseEncoding(split.join(exports.DELIM));\n    var spec = {\n        mark: mark_1.Mark[mark],\n        encoding: encoding\n    };\n    if (data !== undefined) {\n        spec.data = data;\n    }\n    if (config !== undefined) {\n        spec.config = config;\n    }\n    return spec;\n}\nexports.parse = parse;\nfunction shortenEncoding(encoding) {\n    return vlEncoding.map(encoding, function (fieldDef, channel) {\n        return channel + exports.ASSIGN + shortenFieldDef(fieldDef);\n    }).join(exports.DELIM);\n}\nexports.shortenEncoding = shortenEncoding;\nfunction parseEncoding(encodingShorthand) {\n    return encodingShorthand.split(exports.DELIM).reduce(function (m, e) {\n        var split = e.split(exports.ASSIGN), enctype = split[0].trim(), fieldDefShorthand = split[1];\n        m[enctype] = parseFieldDef(fieldDefShorthand);\n        return m;\n    }, {});\n}\nexports.parseEncoding = parseEncoding;\nfunction shortenFieldDef(fieldDef) {\n    return (fieldDef.aggregate ? fieldDef.aggregate + exports.FUNC : '') +\n        (fieldDef.timeUnit ? fieldDef.timeUnit + exports.FUNC : '') +\n        (fieldDef.bin ? 'bin' + exports.FUNC : '') +\n        (fieldDef.field || '') + exports.TYPE + type_1.SHORT_TYPE[fieldDef.type];\n}\nexports.shortenFieldDef = shortenFieldDef;\nfunction shortenFieldDefs(fieldDefs, delim) {\n    if (delim === void 0) { delim = exports.DELIM; }\n    return fieldDefs.map(shortenFieldDef).join(delim);\n}\nexports.shortenFieldDefs = shortenFieldDefs;\nfunction parseFieldDef(fieldDefShorthand) {\n    var split = fieldDefShorthand.split(exports.TYPE);\n    var fieldDef = {\n        field: split[0].trim(),\n        type: type_1.TYPE_FROM_SHORT_TYPE[split[1].trim()]\n    };\n    for (var i = 0; i < aggregate_1.AGGREGATE_OPS.length; i++) {\n        var a = aggregate_1.AGGREGATE_OPS[i];\n        if (fieldDef.field.indexOf(a + '_') === 0) {\n            fieldDef.field = fieldDef.field.substr(a.toString().length + 1);\n            if (a === aggregate_1.AggregateOp.COUNT && fieldDef.field.length === 0) {\n                fieldDef.field = '*';\n            }\n            fieldDef.aggregate = a;\n            break;\n        }\n    }\n    for (var i = 0; i < timeunit_1.TIMEUNITS.length; i++) {\n        var tu = timeunit_1.TIMEUNITS[i];\n        if (fieldDef.field && fieldDef.field.indexOf(tu + '_') === 0) {\n            fieldDef.field = fieldDef.field.substr(fieldDef.field.length + 1);\n            fieldDef.timeUnit = tu;\n            break;\n        }\n    }\n    if (fieldDef.field && fieldDef.field.indexOf('bin_') === 0) {\n        fieldDef.field = fieldDef.field.substr(4);\n        fieldDef.bin = true;\n    }\n    return fieldDef;\n}\nexports.parseFieldDef = parseFieldDef;\n//# sourceMappingURL=shorthand.js.map",
    "\"use strict\";\nvar config_1 = require('./config');\nvar encoding_1 = require('./encoding');\nvar mark_1 = require('./mark');\nvar stack_1 = require('./stack');\nvar channel_1 = require('./channel');\nvar vlEncoding = require('./encoding');\nvar util_1 = require('./util');\nfunction isFacetSpec(spec) {\n    return spec['facet'] !== undefined;\n}\nexports.isFacetSpec = isFacetSpec;\nfunction isExtendedUnitSpec(spec) {\n    if (isSomeUnitSpec(spec)) {\n        var hasRow = encoding_1.has(spec.encoding, channel_1.ROW);\n        var hasColumn = encoding_1.has(spec.encoding, channel_1.COLUMN);\n        return hasRow || hasColumn;\n    }\n    return false;\n}\nexports.isExtendedUnitSpec = isExtendedUnitSpec;\nfunction isUnitSpec(spec) {\n    if (isSomeUnitSpec(spec)) {\n        return !isExtendedUnitSpec(spec);\n    }\n    return false;\n}\nexports.isUnitSpec = isUnitSpec;\nfunction isSomeUnitSpec(spec) {\n    return spec['mark'] !== undefined;\n}\nexports.isSomeUnitSpec = isSomeUnitSpec;\nfunction isLayerSpec(spec) {\n    return spec['layers'] !== undefined;\n}\nexports.isLayerSpec = isLayerSpec;\nfunction normalize(spec) {\n    if (isExtendedUnitSpec(spec)) {\n        return normalizeExtendedUnitSpec(spec);\n    }\n    if (isUnitSpec(spec)) {\n        return normalizeUnitSpec(spec);\n    }\n    return spec;\n}\nexports.normalize = normalize;\nfunction normalizeExtendedUnitSpec(spec) {\n    var hasRow = encoding_1.has(spec.encoding, channel_1.ROW);\n    var hasColumn = encoding_1.has(spec.encoding, channel_1.COLUMN);\n    var encoding = util_1.duplicate(spec.encoding);\n    delete encoding.column;\n    delete encoding.row;\n    return util_1.extend(spec.name ? { name: spec.name } : {}, spec.description ? { description: spec.description } : {}, { data: spec.data }, spec.transform ? { transform: spec.transform } : {}, {\n        facet: util_1.extend(hasRow ? { row: spec.encoding.row } : {}, hasColumn ? { column: spec.encoding.column } : {}),\n        spec: normalizeUnitSpec({\n            mark: spec.mark,\n            encoding: encoding\n        })\n    }, spec.config ? { config: spec.config } : {});\n}\nexports.normalizeExtendedUnitSpec = normalizeExtendedUnitSpec;\nfunction normalizeUnitSpec(spec) {\n    var config = spec.config;\n    var overlayConfig = config && config.overlay;\n    var overlayWithLine = overlayConfig && spec.mark === mark_1.AREA &&\n        util_1.contains([config_1.AreaOverlay.LINEPOINT, config_1.AreaOverlay.LINE], overlayConfig.area);\n    var overlayWithPoint = overlayConfig && ((overlayConfig.line && spec.mark === mark_1.LINE) ||\n        (overlayConfig.area === config_1.AreaOverlay.LINEPOINT && spec.mark === mark_1.AREA));\n    if (spec.mark === mark_1.ERRORBAR) {\n        return normalizeErrorBarUnitSpec(spec);\n    }\n    if (encoding_1.isRanged(spec.encoding)) {\n        return normalizeRangedUnitSpec(spec);\n    }\n    if (isStacked(spec)) {\n        return spec;\n    }\n    if (overlayWithPoint || overlayWithLine) {\n        return normalizeOverlay(spec, overlayWithPoint, overlayWithLine);\n    }\n    return spec;\n}\nexports.normalizeUnitSpec = normalizeUnitSpec;\nfunction normalizeRangedUnitSpec(spec) {\n    if (spec.encoding) {\n        var hasX = encoding_1.has(spec.encoding, channel_1.X);\n        var hasY = encoding_1.has(spec.encoding, channel_1.Y);\n        var hasX2 = encoding_1.has(spec.encoding, channel_1.X2);\n        var hasY2 = encoding_1.has(spec.encoding, channel_1.Y2);\n        if ((hasX2 && !hasX) || (hasY2 && !hasY)) {\n            var normalizedSpec = util_1.duplicate(spec);\n            if (hasX2 && !hasX) {\n                normalizedSpec.encoding.x = normalizedSpec.encoding.x2;\n                delete normalizedSpec.encoding.x2;\n            }\n            if (hasY2 && !hasY) {\n                normalizedSpec.encoding.y = normalizedSpec.encoding.y2;\n                delete normalizedSpec.encoding.y2;\n            }\n            return normalizedSpec;\n        }\n    }\n    return spec;\n}\nexports.normalizeRangedUnitSpec = normalizeRangedUnitSpec;\nfunction normalizeErrorBarUnitSpec(spec) {\n    var layerSpec = util_1.extend(spec.name ? { name: spec.name } : {}, spec.description ? { description: spec.description } : {}, spec.data ? { data: spec.data } : {}, spec.transform ? { transform: spec.transform } : {}, spec.config ? { config: spec.config } : {}, { layers: [] });\n    if (!spec.encoding) {\n        return layerSpec;\n    }\n    if (spec.mark === mark_1.ERRORBAR) {\n        var ruleSpec = {\n            mark: mark_1.RULE,\n            encoding: util_1.extend(spec.encoding.x ? { x: util_1.duplicate(spec.encoding.x) } : {}, spec.encoding.y ? { y: util_1.duplicate(spec.encoding.y) } : {}, spec.encoding.x2 ? { x2: util_1.duplicate(spec.encoding.x2) } : {}, spec.encoding.y2 ? { y2: util_1.duplicate(spec.encoding.y2) } : {}, {})\n        };\n        var lowerTickSpec = {\n            mark: mark_1.TICK,\n            encoding: util_1.extend(spec.encoding.x ? { x: util_1.duplicate(spec.encoding.x) } : {}, spec.encoding.y ? { y: util_1.duplicate(spec.encoding.y) } : {}, spec.encoding.size ? { size: util_1.duplicate(spec.encoding.size) } : {}, {})\n        };\n        var upperTickSpec = {\n            mark: mark_1.TICK,\n            encoding: util_1.extend({\n                x: spec.encoding.x2 ? util_1.duplicate(spec.encoding.x2) : util_1.duplicate(spec.encoding.x),\n                y: spec.encoding.y2 ? util_1.duplicate(spec.encoding.y2) : util_1.duplicate(spec.encoding.y)\n            }, spec.encoding.size ? { size: util_1.duplicate(spec.encoding.size) } : {})\n        };\n        layerSpec.layers.push(normalizeUnitSpec(ruleSpec));\n        layerSpec.layers.push(normalizeUnitSpec(lowerTickSpec));\n        layerSpec.layers.push(normalizeUnitSpec(upperTickSpec));\n    }\n    return layerSpec;\n}\nexports.normalizeErrorBarUnitSpec = normalizeErrorBarUnitSpec;\nfunction normalizeOverlay(spec, overlayWithPoint, overlayWithLine) {\n    var outerProps = ['name', 'description', 'data', 'transform'];\n    var baseSpec = util_1.omit(spec, outerProps.concat('config'));\n    var baseConfig = util_1.duplicate(spec.config);\n    delete baseConfig.overlay;\n    var layerSpec = util_1.extend(util_1.pick(spec, outerProps), { layers: [baseSpec] }, util_1.keys(baseConfig).length > 0 ? { config: baseConfig } : {});\n    if (overlayWithLine) {\n        var lineSpec = util_1.duplicate(baseSpec);\n        lineSpec.mark = mark_1.LINE;\n        var markConfig = util_1.extend({}, config_1.defaultOverlayConfig.lineStyle, spec.config.overlay.lineStyle);\n        if (util_1.keys(markConfig).length > 0) {\n            lineSpec.config = { mark: markConfig };\n        }\n        layerSpec.layers.push(lineSpec);\n    }\n    if (overlayWithPoint) {\n        var pointSpec = util_1.duplicate(baseSpec);\n        pointSpec.mark = mark_1.POINT;\n        var markConfig = util_1.extend({}, config_1.defaultOverlayConfig.pointStyle, spec.config.overlay.pointStyle);\n        ;\n        if (util_1.keys(markConfig).length > 0) {\n            pointSpec.config = { mark: markConfig };\n        }\n        layerSpec.layers.push(pointSpec);\n    }\n    return layerSpec;\n}\nexports.normalizeOverlay = normalizeOverlay;\nfunction alwaysNoOcclusion(spec) {\n    return vlEncoding.isAggregate(spec.encoding);\n}\nexports.alwaysNoOcclusion = alwaysNoOcclusion;\nfunction fieldDefs(spec) {\n    return vlEncoding.fieldDefs(spec.encoding);\n}\nexports.fieldDefs = fieldDefs;\n;\nfunction getCleanSpec(spec) {\n    return spec;\n}\nexports.getCleanSpec = getCleanSpec;\nfunction isStacked(spec) {\n    return stack_1.stack(spec.mark, spec.encoding, spec.config) !== null;\n}\nexports.isStacked = isStacked;\nfunction transpose(spec) {\n    var oldenc = spec.encoding;\n    var encoding = util_1.duplicate(spec.encoding);\n    encoding.x = oldenc.y;\n    encoding.y = oldenc.x;\n    encoding.row = oldenc.column;\n    encoding.column = oldenc.row;\n    spec.encoding = encoding;\n    return spec;\n}\nexports.transpose = transpose;\n//# sourceMappingURL=spec.js.map",
    "\"use strict\";\nvar channel_1 = require('./channel');\nvar encoding_1 = require('./encoding');\nvar mark_1 = require('./mark');\nvar util_1 = require('./util');\n(function (StackOffset) {\n    StackOffset[StackOffset[\"ZERO\"] = 'zero'] = \"ZERO\";\n    StackOffset[StackOffset[\"CENTER\"] = 'center'] = \"CENTER\";\n    StackOffset[StackOffset[\"NORMALIZE\"] = 'normalize'] = \"NORMALIZE\";\n    StackOffset[StackOffset[\"NONE\"] = 'none'] = \"NONE\";\n})(exports.StackOffset || (exports.StackOffset = {}));\nvar StackOffset = exports.StackOffset;\nfunction stack(mark, encoding, config) {\n    var stacked = (config && config.mark) ? config.mark.stacked : undefined;\n    if (util_1.contains([StackOffset.NONE, null, false], stacked)) {\n        return null;\n    }\n    if (!util_1.contains([mark_1.BAR, mark_1.AREA], mark)) {\n        return null;\n    }\n    if (!encoding_1.isAggregate(encoding)) {\n        return null;\n    }\n    var stackByChannels = channel_1.STACK_GROUP_CHANNELS.reduce(function (sc, channel) {\n        if (encoding_1.has(encoding, channel) && !encoding[channel].aggregate) {\n            sc.push(channel);\n        }\n        return sc;\n    }, []);\n    if (stackByChannels.length === 0) {\n        return null;\n    }\n    var hasXField = encoding_1.has(encoding, channel_1.X);\n    var hasYField = encoding_1.has(encoding, channel_1.Y);\n    var xIsAggregate = hasXField && !!encoding.x.aggregate;\n    var yIsAggregate = hasYField && !!encoding.y.aggregate;\n    if (xIsAggregate !== yIsAggregate) {\n        return {\n            groupbyChannel: xIsAggregate ? (hasYField ? channel_1.Y : null) : (hasXField ? channel_1.X : null),\n            fieldChannel: xIsAggregate ? channel_1.X : channel_1.Y,\n            stackByChannels: stackByChannels,\n            offset: stacked || StackOffset.ZERO\n        };\n    }\n    return null;\n}\nexports.stack = stack;\n//# sourceMappingURL=stack.js.map",
    "\"use strict\";\n(function (TimeUnit) {\n    TimeUnit[TimeUnit[\"YEAR\"] = 'year'] = \"YEAR\";\n    TimeUnit[TimeUnit[\"MONTH\"] = 'month'] = \"MONTH\";\n    TimeUnit[TimeUnit[\"DAY\"] = 'day'] = \"DAY\";\n    TimeUnit[TimeUnit[\"DATE\"] = 'date'] = \"DATE\";\n    TimeUnit[TimeUnit[\"HOURS\"] = 'hours'] = \"HOURS\";\n    TimeUnit[TimeUnit[\"MINUTES\"] = 'minutes'] = \"MINUTES\";\n    TimeUnit[TimeUnit[\"SECONDS\"] = 'seconds'] = \"SECONDS\";\n    TimeUnit[TimeUnit[\"MILLISECONDS\"] = 'milliseconds'] = \"MILLISECONDS\";\n    TimeUnit[TimeUnit[\"YEARMONTH\"] = 'yearmonth'] = \"YEARMONTH\";\n    TimeUnit[TimeUnit[\"YEARMONTHDAY\"] = 'yearmonthday'] = \"YEARMONTHDAY\";\n    TimeUnit[TimeUnit[\"YEARMONTHDATE\"] = 'yearmonthdate'] = \"YEARMONTHDATE\";\n    TimeUnit[TimeUnit[\"YEARDAY\"] = 'yearday'] = \"YEARDAY\";\n    TimeUnit[TimeUnit[\"YEARDATE\"] = 'yeardate'] = \"YEARDATE\";\n    TimeUnit[TimeUnit[\"YEARMONTHDAYHOURS\"] = 'yearmonthdayhours'] = \"YEARMONTHDAYHOURS\";\n    TimeUnit[TimeUnit[\"YEARMONTHDAYHOURSMINUTES\"] = 'yearmonthdayhoursminutes'] = \"YEARMONTHDAYHOURSMINUTES\";\n    TimeUnit[TimeUnit[\"YEARMONTHDAYHOURSMINUTESSECONDS\"] = 'yearmonthdayhoursminutesseconds'] = \"YEARMONTHDAYHOURSMINUTESSECONDS\";\n    TimeUnit[TimeUnit[\"HOURSMINUTES\"] = 'hoursminutes'] = \"HOURSMINUTES\";\n    TimeUnit[TimeUnit[\"HOURSMINUTESSECONDS\"] = 'hoursminutesseconds'] = \"HOURSMINUTESSECONDS\";\n    TimeUnit[TimeUnit[\"MINUTESSECONDS\"] = 'minutesseconds'] = \"MINUTESSECONDS\";\n    TimeUnit[TimeUnit[\"SECONDSMILLISECONDS\"] = 'secondsmilliseconds'] = \"SECONDSMILLISECONDS\";\n    TimeUnit[TimeUnit[\"QUARTER\"] = 'quarter'] = \"QUARTER\";\n    TimeUnit[TimeUnit[\"YEARQUARTER\"] = 'yearquarter'] = \"YEARQUARTER\";\n    TimeUnit[TimeUnit[\"QUARTERMONTH\"] = 'quartermonth'] = \"QUARTERMONTH\";\n    TimeUnit[TimeUnit[\"YEARQUARTERMONTH\"] = 'yearquartermonth'] = \"YEARQUARTERMONTH\";\n})(exports.TimeUnit || (exports.TimeUnit = {}));\nvar TimeUnit = exports.TimeUnit;\nexports.TIMEUNITS = [\n    TimeUnit.YEAR,\n    TimeUnit.MONTH,\n    TimeUnit.DAY,\n    TimeUnit.DATE,\n    TimeUnit.HOURS,\n    TimeUnit.MINUTES,\n    TimeUnit.SECONDS,\n    TimeUnit.MILLISECONDS,\n    TimeUnit.YEARMONTH,\n    TimeUnit.YEARMONTHDAY,\n    TimeUnit.YEARMONTHDATE,\n    TimeUnit.YEARDAY,\n    TimeUnit.YEARDATE,\n    TimeUnit.YEARMONTHDAYHOURS,\n    TimeUnit.YEARMONTHDAYHOURSMINUTES,\n    TimeUnit.YEARMONTHDAYHOURSMINUTESSECONDS,\n    TimeUnit.HOURSMINUTES,\n    TimeUnit.HOURSMINUTESSECONDS,\n    TimeUnit.MINUTESSECONDS,\n    TimeUnit.SECONDSMILLISECONDS,\n    TimeUnit.QUARTER,\n    TimeUnit.YEARQUARTER,\n    TimeUnit.QUARTERMONTH,\n    TimeUnit.YEARQUARTERMONTH,\n];\nfunction template(timeUnit, field, shortTimeLabels) {\n    if (!timeUnit) {\n        return undefined;\n    }\n    var dateComponents = [];\n    if (containsTimeUnit(timeUnit, TimeUnit.YEAR)) {\n        dateComponents.push(shortTimeLabels ? '%y' : '%Y');\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.QUARTER)) {\n        dateComponents.push('\\'}}Q{{' + field + ' | quarter}}{{' + field + ' | time:\\'');\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.MONTH)) {\n        dateComponents.push(shortTimeLabels ? '%b' : '%B');\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.DAY)) {\n        dateComponents.push(shortTimeLabels ? '%a' : '%A');\n    }\n    else if (containsTimeUnit(timeUnit, TimeUnit.DATE)) {\n        dateComponents.push('%d');\n    }\n    var timeComponents = [];\n    if (containsTimeUnit(timeUnit, TimeUnit.HOURS)) {\n        timeComponents.push('%H');\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.MINUTES)) {\n        timeComponents.push('%M');\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.SECONDS)) {\n        timeComponents.push('%S');\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.MILLISECONDS)) {\n        timeComponents.push('%L');\n    }\n    var out = [];\n    if (dateComponents.length > 0) {\n        out.push(dateComponents.join('-'));\n    }\n    if (timeComponents.length > 0) {\n        out.push(timeComponents.join(':'));\n    }\n    if (out.length > 0) {\n        var template_1 = '{{' + field + ' | time:\\'' + out.join(' ') + '\\'}}';\n        return template_1.replace(new RegExp('{{' + field + ' \\\\| time:\\'\\'}}', 'g'), '');\n    }\n    else {\n        return undefined;\n    }\n}\nexports.template = template;\nfunction containsTimeUnit(fullTimeUnit, timeUnit) {\n    var fullTimeUnitStr = fullTimeUnit.toString();\n    var timeUnitStr = timeUnit.toString();\n    return fullTimeUnitStr.indexOf(timeUnitStr) > -1;\n}\nexports.containsTimeUnit = containsTimeUnit;\n//# sourceMappingURL=timeunit.js.map",
    "\"use strict\";\n(function (Type) {\n    Type[Type[\"QUANTITATIVE\"] = 'quantitative'] = \"QUANTITATIVE\";\n    Type[Type[\"ORDINAL\"] = 'ordinal'] = \"ORDINAL\";\n    Type[Type[\"TEMPORAL\"] = 'temporal'] = \"TEMPORAL\";\n    Type[Type[\"NOMINAL\"] = 'nominal'] = \"NOMINAL\";\n    Type[Type[\"GEOJSON\"] = 'geojson'] = \"GEOJSON\";\n    Type[Type[\"LONGITUDE\"] = 'longitude'] = \"LONGITUDE\";\n    Type[Type[\"LATITUDE\"] = 'latitude'] = \"LATITUDE\";\n})(exports.Type || (exports.Type = {}));\nvar Type = exports.Type;\nexports.QUANTITATIVE = Type.QUANTITATIVE;\nexports.ORDINAL = Type.ORDINAL;\nexports.TEMPORAL = Type.TEMPORAL;\nexports.NOMINAL = Type.NOMINAL;\nexports.GEOJSON = Type.GEOJSON;\nexports.LONGITUDE = Type.LONGITUDE;\nexports.LATITUDE = Type.LATITUDE;\nexports.SHORT_TYPE = {\n    quantitative: 'Q',\n    temporal: 'T',\n    nominal: 'N',\n    ordinal: 'O'\n};\nexports.TYPE_FROM_SHORT_TYPE = {\n    Q: exports.QUANTITATIVE,\n    T: exports.TEMPORAL,\n    O: exports.ORDINAL,\n    N: exports.NOMINAL\n};\nfunction getFullName(type) {\n    var typeString = type;\n    return exports.TYPE_FROM_SHORT_TYPE[typeString.toUpperCase()] ||\n        typeString.toLowerCase();\n}\nexports.getFullName = getFullName;\n//# sourceMappingURL=type.js.map",
    "\"use strict\";\nvar stringify = require('json-stable-stringify');\nvar util_1 = require('datalib/src/util');\nexports.keys = util_1.keys;\nexports.extend = util_1.extend;\nexports.duplicate = util_1.duplicate;\nexports.isArray = util_1.isArray;\nexports.vals = util_1.vals;\nexports.truncate = util_1.truncate;\nexports.toMap = util_1.toMap;\nexports.isObject = util_1.isObject;\nexports.isString = util_1.isString;\nexports.isNumber = util_1.isNumber;\nexports.isBoolean = util_1.isBoolean;\nvar util_2 = require('datalib/src/util');\nvar generate_1 = require('datalib/src/generate');\nexports.range = generate_1.range;\nvar encoding_1 = require('./encoding');\nexports.has = encoding_1.has;\nvar channel_1 = require('./channel');\nexports.Channel = channel_1.Channel;\nvar util_3 = require('datalib/src/util');\nfunction pick(obj, props) {\n    var copy = {};\n    props.forEach(function (prop) {\n        if (obj.hasOwnProperty(prop)) {\n            copy[prop] = obj[prop];\n        }\n    });\n    return copy;\n}\nexports.pick = pick;\nfunction omit(obj, props) {\n    var copy = util_2.duplicate(obj);\n    props.forEach(function (prop) {\n        delete copy[prop];\n    });\n    return copy;\n}\nexports.omit = omit;\nfunction hash(a) {\n    if (util_3.isString(a) || util_3.isNumber(a) || util_3.isBoolean(a)) {\n        return String(a);\n    }\n    return stringify(a);\n}\nexports.hash = hash;\nfunction contains(array, item) {\n    return array.indexOf(item) > -1;\n}\nexports.contains = contains;\nfunction without(array, excludedItems) {\n    return array.filter(function (item) {\n        return !contains(excludedItems, item);\n    });\n}\nexports.without = without;\nfunction union(array, other) {\n    return array.concat(without(other, array));\n}\nexports.union = union;\nfunction forEach(obj, f, thisArg) {\n    if (obj.forEach) {\n        obj.forEach.call(thisArg, f);\n    }\n    else {\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                f.call(thisArg, obj[k], k, obj);\n            }\n        }\n    }\n}\nexports.forEach = forEach;\nfunction reduce(obj, f, init, thisArg) {\n    if (obj.reduce) {\n        return obj.reduce.call(thisArg, f, init);\n    }\n    else {\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                init = f.call(thisArg, init, obj[k], k, obj);\n            }\n        }\n        return init;\n    }\n}\nexports.reduce = reduce;\nfunction map(obj, f, thisArg) {\n    if (obj.map) {\n        return obj.map.call(thisArg, f);\n    }\n    else {\n        var output = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                output.push(f.call(thisArg, obj[k], k, obj));\n            }\n        }\n        return output;\n    }\n}\nexports.map = map;\nfunction some(arr, f) {\n    var i = 0;\n    for (var k = 0; k < arr.length; k++) {\n        if (f(arr[k], k, i++)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.some = some;\nfunction every(arr, f) {\n    var i = 0;\n    for (var k = 0; k < arr.length; k++) {\n        if (!f(arr[k], k, i++)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.every = every;\nfunction flatten(arrays) {\n    return [].concat.apply([], arrays);\n}\nexports.flatten = flatten;\nfunction mergeDeep(dest) {\n    var src = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        src[_i - 1] = arguments[_i];\n    }\n    for (var i = 0; i < src.length; i++) {\n        dest = deepMerge_(dest, src[i]);\n    }\n    return dest;\n}\nexports.mergeDeep = mergeDeep;\n;\nfunction deepMerge_(dest, src) {\n    if (typeof src !== 'object' || src === null) {\n        return dest;\n    }\n    for (var p in src) {\n        if (!src.hasOwnProperty(p)) {\n            continue;\n        }\n        if (src[p] === undefined) {\n            continue;\n        }\n        if (typeof src[p] !== 'object' || src[p] === null) {\n            dest[p] = src[p];\n        }\n        else if (typeof dest[p] !== 'object' || dest[p] === null) {\n            dest[p] = mergeDeep(src[p].constructor === Array ? [] : {}, src[p]);\n        }\n        else {\n            mergeDeep(dest[p], src[p]);\n        }\n    }\n    return dest;\n}\nvar dlBin = require('datalib/src/bins/bins');\nfunction getbins(stats, maxbins) {\n    return dlBin({\n        min: stats.min,\n        max: stats.max,\n        maxbins: maxbins\n    });\n}\nexports.getbins = getbins;\nfunction unique(values, f) {\n    var results = [];\n    var u = {}, v, i, n;\n    for (i = 0, n = values.length; i < n; ++i) {\n        v = f ? f(values[i]) : values[i];\n        if (v in u) {\n            continue;\n        }\n        u[v] = 1;\n        results.push(values[i]);\n    }\n    return results;\n}\nexports.unique = unique;\n;\nfunction warning(message) {\n    console.warn('[VL Warning]', message);\n}\nexports.warning = warning;\nfunction error(message) {\n    console.error('[VL Error]', message);\n}\nexports.error = error;\nfunction differ(dict, other) {\n    for (var key in dict) {\n        if (dict.hasOwnProperty(key)) {\n            if (other[key] && dict[key] && other[key] !== dict[key]) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexports.differ = differ;\n//# sourceMappingURL=util.js.map",
    "\"use strict\";\nvar util_1 = require('./util');\nvar mark_1 = require('./mark');\nexports.DEFAULT_REQUIRED_CHANNEL_MAP = {\n    text: ['text'],\n    line: ['x', 'y'],\n    area: ['x', 'y']\n};\nexports.DEFAULT_SUPPORTED_CHANNEL_TYPE = {\n    bar: util_1.toMap(['row', 'column', 'x', 'y', 'size', 'color', 'detail']),\n    line: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'detail']),\n    area: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'detail']),\n    tick: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'detail']),\n    circle: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'size', 'detail']),\n    square: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'size', 'detail']),\n    point: util_1.toMap(['row', 'column', 'x', 'y', 'color', 'size', 'detail', 'shape']),\n    text: util_1.toMap(['row', 'column', 'size', 'color', 'text'])\n};\nfunction getEncodingMappingError(spec, requiredChannelMap, supportedChannelMap) {\n    if (requiredChannelMap === void 0) { requiredChannelMap = exports.DEFAULT_REQUIRED_CHANNEL_MAP; }\n    if (supportedChannelMap === void 0) { supportedChannelMap = exports.DEFAULT_SUPPORTED_CHANNEL_TYPE; }\n    var mark = spec.mark;\n    var encoding = spec.encoding;\n    var requiredChannels = requiredChannelMap[mark];\n    var supportedChannels = supportedChannelMap[mark];\n    for (var i in requiredChannels) {\n        if (!(requiredChannels[i] in encoding)) {\n            return 'Missing encoding channel \\\"' + requiredChannels[i] +\n                '\\\" for mark \\\"' + mark + '\\\"';\n        }\n    }\n    for (var channel in encoding) {\n        if (!supportedChannels[channel]) {\n            return 'Encoding channel \\\"' + channel +\n                '\\\" is not supported by mark type \\\"' + mark + '\\\"';\n        }\n    }\n    if (mark === mark_1.BAR && !encoding.x && !encoding.y) {\n        return 'Missing both x and y for bar';\n    }\n    return null;\n}\nexports.getEncodingMappingError = getEncodingMappingError;\n//# sourceMappingURL=validate.js.map"
  ]
}